<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Hotspots per Twine (Harlowe)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .panel {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #imageEditor {
            flex: 2;
            min-width: 400px;
            position: relative;
            cursor: crosshair;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 0;
            height: auto;
            min-height: 400px;
            border: 1px dashed #ccc;
            overflow: hidden; /* Important per controlar el desbordament visual */
            box-sizing: border-box; /* Per incloure padding i border en el width/height */
        }
        #imageDisplay {
            max-width: 100%;
            height: auto;
            display: none;
            user-select: none; /* Evita que la imatge es pugui seleccionar amb el ratolí */
            -webkit-user-drag: none; /* Evita que la imatge es pugui arrossegar */
        }
        #drawingInstructions {
            text-align: center;
            margin-top: 50px;
            color: #666;
        }
        .hotspot-area {
            position: absolute;
            border: 2px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.2);
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            font-size: 14px;
            box-sizing: border-box;
            z-index: 5; /* Base z-index for the hotspot area */
        }
        .hotspot-name-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 2px 5px;
            background: rgba(0,0,0,0.7);
            border-radius: 3px;
            white-space: nowrap;
            pointer-events: none; /* Permet el clic a través del nom */
            z-index: 15; /* Higher z-index to be above the hotspot area */
        }
        .hotspot-area:hover {
            background-color: rgba(0, 123, 255, 0.4);
        }
        #hotspotsConfig {
            flex: 1;
            min-width: 300px;
        }
        .hotspot-item {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px; /* Increased margin-bottom for spacing between hotspot items */
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .hotspot-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .hotspot-item input[type="text"],
        .hotspot-item select,
        .hotspot-item textarea {
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px; /* Kept existing margin-bottom for input fields */
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .hotspot-item textarea {
            resize: vertical;
            min-height: 60px;
        }
        .hotspot-item button.delete-config-button {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            float: right;
            margin-top: 10px; /* Added margin-top to separate from previous fields */
        }
        .hotspot-item button.delete-config-button:hover {
            background-color: #c82333;
        }
        #outputCode {
            width: calc(100% - 40px);
            height: 300px;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #e9ecef;
            resize: vertical;
        }
        .button-group {
            margin-top: 10px;
        }
        .button-group button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        .button-group button:hover {
            background-color: #0056b3;
        }
        #copyFeedback {
            display: none;
            margin-left: 10px;
            color: green;
            font-weight: bold;
        }
        .hotspot-delete-button-visual {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #dc3545;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            z-index: 20; /* Even higher z-index to be above the hotspot area */
        }
        .hotspot-delete-button-visual:hover {
            background-color: #c82333;
        }
        /* Styles for the resize handle */
        .hotspot-resize-handle {
            position: absolute;
            bottom: -5px; /* Adjust to position slightly outside */
            right: -5px; /* Adjust to position slightly outside */
            width: 10px;
            height: 10px;
            background-color: white;
            border: 1px solid #007bff;
            border-radius: 50%;
            cursor: nwse-resize; /* Diagonal resize cursor */
            z-index: 25; /* Higher than delete button and name display */
        }
        .hidden-field {
            display: none;
        }
        #editorImageInfoDisplay {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 1em;
            display: none;
            z-index: 100; /* Assegura que estigui per sobre de tot */
            pointer-events: none; /* No interfereix amb els clics */
        }
        /* New styles for condition labels */
        .condition-label-container label,
        .condition-fields label {
            color: darkred; /* Changed to dark red */
        }
    </style>
</head>
<body>
    <h1>Editor de Hotspots per a Històries de Twine (Harlowe)</h1>
    <p>1. Carrega una imatge. 2. Dibuixa rectangles sobre les àrees que vulguis fer clicables. 3. Configura cada hotspot. 4. Copia el codi generat i enganxa'l al passatge de Twine.</p>

    <div class="container">
        <div class="panel" id="imageConfig">
            <h2>Configuració de la Imatge</h2>
            <label for="imageUpload">Carregar Imatge:</label>
            <input type="file" id="imageUpload" accept="image/*">
            <div id="imageEditor">
                <img id="imageDisplay" src="" alt="Imatge de la història" style="display: none;">
                <p id="drawingInstructions">Carrega una imatge i dibuixa un hotspot!</p>
                <div id="editorImageInfoDisplay"></div>
            </div>
        </div>

        <div class="panel" id="hotspotsConfig">
            <h2>Hotspots Configurats</h2>
            <div id="hotspotsContainer">
                <p>No hi ha hotspots creats.</p>
            </div>
        </div>
    </div>

    <div class="panel">
        <h2>Codi Twine (Harlowe) Generat</h2>
        <textarea id="outputCode"></textarea>
        <div class="button-group">
            <button id="copyCodeButton">Copiar Codi</button>
            <button id="loadCodeButton">Carregar Codi existent</button>
            <span id="copyFeedback">Codi copiat!</span>
        </div>
    </div>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const imageDisplay = document.getElementById('imageDisplay');
        const imageEditor = document.getElementById('imageEditor');
        const hotspotsContainerEl = document.getElementById('hotspotsContainer');
        const outputCode = document.getElementById('outputCode');
        const copyCodeButton = document.getElementById('copyCodeButton');
        const drawingInstructions = document.getElementById('drawingInstructions');
        const editorImageInfoDisplay = document.getElementById('editorImageInfoDisplay');
        const copyFeedback = document.getElementById('copyFeedback');
        const loadCodeButton = document.getElementById('loadCodeButton');

        let isDrawing = false;
        let isDragging = false;
        let isResizing = false; // New state for resizing
        let activeHotspotElement = null;
        let dragOffsetX, dragOffsetY;
        let initialHotspotWidth, initialHotspotHeight; // New variables for resizing
        let initialMouseX, initialMouseY; // New variables for resizing
        let startX, startY;
        let currentRect = null;
        let hotspots = [];
        let hotspotIdCounter = 0;

        // Function to hide the "Code copied!" feedback
        function hideCopyFeedback() {
            copyFeedback.classList.remove('show');
        }

        // Event listener for image upload
        imageUpload.addEventListener('change', (e) => {
            hideCopyFeedback(); // Hide feedback on new image upload
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    imageDisplay.src = event.target.result;
                    imageDisplay.style.display = 'block';
                    drawingInstructions.style.display = 'none';
                    editorImageInfoDisplay.style.display = 'none';

                    imageDisplay.onload = () => {
                        // Adjust image editor height based on image dimensions
                        const extraSpace = 80;
                        imageEditor.style.minHeight = imageDisplay.offsetHeight + extraSpace + 'px';
                        imageEditor.style.height = imageDisplay.offsetHeight + extraSpace + 'px';
                        hotspots = []; // Clear existing hotspots when a new image is loaded
                        renderHotspots();
                        generateTwineCode();
                    };
                    imageDisplay.onerror = () => {
                        // Handle image loading errors
                        alert("Error al carregar la imatge.");
                        imageDisplay.src = '';
                        imageDisplay.style.display = 'none';
                        drawingInstructions.style.display = 'block';
                        editorImageInfoDisplay.style.display = 'none';
                    }
                };
                reader.readAsDataURL(file);
            } else {
                // Reset display if no file is selected
                imageDisplay.src = '';
                imageDisplay.style.display = 'none';
                drawingInstructions.style.display = 'block';
                editorImageInfoDisplay.style.display = 'none';
                imageEditor.style.height = 'auto';
                imageEditor.style.minHeight = '400px';
                hotspots = [];
                renderHotspots();
                generateTwineCode();
            }
        });

        // Mouse down event listener for image editor (drawing, dragging, and resizing)
        imageEditor.addEventListener('mousedown', (e) => {
            hideCopyFeedback(); // Hide feedback on interaction
            if (imageDisplay.style.display === 'none' || !imageDisplay.src) return; // Only interact if an image is loaded
            if (e.target.classList.contains('hotspot-delete-button-visual')) return; // Ignore clicks on delete button

            if (e.target.classList.contains('hotspot-resize-handle')) {
                isResizing = true;
                activeHotspotElement = e.target.parentElement; // Get the parent hotspot-area
                initialHotspotWidth = activeHotspotElement.offsetWidth;
                initialHotspotHeight = activeHotspotElement.offsetHeight;
                initialMouseX = e.clientX;
                initialMouseY = e.clientY;
                activeHotspotElement.style.cursor = 'nwse-resize'; // Keep resize cursor
                e.stopPropagation(); // Prevent drawing or dragging the hotspot
            } else if (e.target.classList.contains('hotspot-area')) {
                isDragging = true;
                activeHotspotElement = e.target;
                const hotspotRect = activeHotspotElement.getBoundingClientRect();
                dragOffsetX = e.clientX - hotspotRect.left;
                dragOffsetY = e.clientY - hotspotRect.top;
                activeHotspotElement.style.cursor = 'grabbing';
                e.stopPropagation();
            } else if (imageEditor.contains(e.target) && (e.target === imageDisplay || e.target === imageEditor || e.target.parentElement === imageEditor || e.target.parentElement.parentElement === imageEditor ) ) {
                isDrawing = true;
                const imageRect = imageDisplay.getBoundingClientRect();
                startX = e.clientX - imageRect.left;
                startY = e.clientY - imageRect.top;
                currentRect = document.createElement('div');
                currentRect.classList.add('hotspot-area');
                const editorRect = imageEditor.getBoundingClientRect();
                currentRect.style.left = `${e.clientX - editorRect.left}px`;
                currentRect.style.top = `${e.clientY - editorRect.top}px`;
                currentRect.style.width = '0px';
                currentRect.style.height = '0px';
                currentRect.style.cursor = 'crosshair';
                imageEditor.appendChild(currentRect);
                imageEditor.style.cursor = 'grabbing';
            }
        });

        // Mouse move event listener for drawing, dragging, and resizing
        document.addEventListener('mousemove', (e) => {
            if (isDrawing && currentRect) {
                // Update dimensions of the new hotspot being drawn
                const imageRect = imageDisplay.getBoundingClientRect(), editorRect = imageEditor.getBoundingClientRect();
                let currentMouseEventX_onImage = e.clientX - imageRect.left, currentMouseEventY_onImage = e.clientY - imageRect.top;
                let rLeft = Math.min(startX, currentMouseEventX_onImage), rTop = Math.min(startY, currentMouseEventY_onImage),
                    rRight = Math.max(startX, currentMouseEventX_onImage), rBottom = Math.max(startY, currentMouseEventY_onImage);
                
                // Clamp coordinates to image boundaries
                rLeft = Math.max(0, rLeft);
                rTop = Math.max(0, rTop);
                rRight = Math.min(imageRect.width, rRight);
                rBottom = Math.min(imageRect.height, rBottom);
                
                let rWidth = rRight - rLeft, rHeight = rBottom - rTop;

                if (rWidth < 0) rWidth = 0;
                if (rHeight < 0) rHeight = 0;

                currentRect.style.left = `${(imageRect.left - editorRect.left) + rLeft}px`;
                currentRect.style.top = `${(imageRect.top - editorRect.top) + rTop}px`;
                currentRect.style.width = `${rWidth}px`;
                currentRect.style.height = `${rHeight}px`;
            } else if (isDragging && activeHotspotElement) {
                // Update position of the dragged hotspot
                const imageRect = imageDisplay.getBoundingClientRect(), editorRect = imageEditor.getBoundingClientRect();
                let newLeftInEditor = e.clientX - editorRect.left - dragOffsetX, newTopInEditor = e.clientY - editorRect.top - dragOffsetY;
                const hotspotWidth = activeHotspotElement.offsetWidth, hotspotHeight = activeHotspotElement.offsetHeight,
                      imageLeftInEditor = imageRect.left - editorRect.left, imageTopInEditor = imageRect.top - editorRect.top,
                      imageRightInEditor = imageLeftInEditor + imageRect.width, imageBottomInEditor = imageTopInEditor + imageRect.height;
                
                // Clamp hotspot position to image boundaries
                newLeftInEditor = Math.max(imageLeftInEditor, Math.min(newLeftInEditor, imageRightInEditor - hotspotWidth));
                newTopInEditor = Math.max(imageTopInEditor, Math.min(newTopInEditor, imageBottomInEditor - hotspotHeight));
                
                activeHotspotElement.style.left = `${newLeftInEditor}px`;
                activeHotspotElement.style.top = `${newTopInEditor}px`;
            } else if (isResizing && activeHotspotElement) {
                const imageRect = imageDisplay.getBoundingClientRect(), editorRect = imageEditor.getBoundingClientRect();
                const imageLeftInEditor = imageRect.left - editorRect.left;
                const imageTopInEditor = imageRect.top - editorRect.top;
                const imageRightInEditor = imageLeftInEditor + imageRect.width;
                const imageBottomInEditor = imageTopInEditor + imageRect.height;

                let newWidth = initialHotspotWidth + (e.clientX - initialMouseX);
                let newHeight = initialHotspotHeight + (e.clientY - initialMouseY);

                // Get current position of the hotspot
                const currentLeft = parseFloat(activeHotspotElement.style.left);
                const currentTop = parseFloat(activeHotspotElement.style.top);

                // Clamp new width/height to image boundaries and minimum size (e.g., 5px)
                newWidth = Math.max(5, Math.min(newWidth, imageRightInEditor - currentLeft));
                newHeight = Math.max(5, Math.min(newHeight, imageBottomInEditor - currentTop));

                activeHotspotElement.style.width = `${newWidth}px`;
                activeHotspotElement.style.height = `${newHeight}px`;
            }
        });

        // Mouse up event listener for finishing drawing, dragging, or resizing
        document.addEventListener('mouseup', (e) => {
            if (isDrawing && currentRect) {
                // Finish drawing a new hotspot
                isDrawing = false;
                const natW = imageDisplay.naturalWidth, natH = imageDisplay.naturalHeight,
                      dispW = imageDisplay.offsetWidth, dispH = imageDisplay.offsetHeight;

                const hotspotRectVis = currentRect.getBoundingClientRect(), imageRectVis = imageDisplay.getBoundingClientRect();
                let l_disp = hotspotRectVis.left - imageRectVis.left, t_disp = hotspotRectVis.top - imageRectVis.top,
                    w_disp = hotspotRectVis.width, h_disp = hotspotRectVis.height;
                currentRect.remove(); // Remove the temporary drawing rectangle
                currentRect = null;

                if (w_disp >= 5 && h_disp >= 5 && dispW && dispH) { // Only add if it's a reasonable size
                    const sX = natW / dispW, sY = natH / dispH;
                    const fL = l_disp * sX, fT = t_disp * sY, fW = w_disp * sX, fH = h_disp * sY;

                    const coords = [Math.round(fL),Math.round(fT),Math.round(fL+fW),Math.round(fT+fH)].join(',');
                    hotspotIdCounter++;
                    hotspots.push({
                        id: hotspotIdCounter,
                        coords: coords,
                        name: `Hotspot ${hotspotIdCounter}`,
                        type: 'passage',
                        value: '', // For passage type
                        titleText: '',
                        sound: '',
                        infoText: '', // This field will now store the Harlowe text
                        variable: '', // New field for setter variable name
                        valor: '', // New field for setter variable value
                        titleTextSetter: '',
                        soundSetter: '',
                        infoTextSetter: '', // This field will now store the Harlowe text
                        infoTextSetter2: '', // New field for alternative info text for setter
                        hasCondition: false,
                        conditionVariable: '',
                        conditionValue: ''
                    });
                }
                renderHotspots();
                generateTwineCode();
            } else if (isDragging && activeHotspotElement) {
                isDragging = false;
                const hotspotId = parseInt(activeHotspotElement.dataset.hotspotId);
                const hotspot = hotspots.find(h => h.id === hotspotId);
                if (hotspot) {
                    const natW = imageDisplay.naturalWidth, natH = imageDisplay.naturalHeight,
                          dispW = imageDisplay.offsetWidth, dispH = imageDisplay.offsetHeight;
                    if (dispW && dispH) {
                        const hotspotRectVis = activeHotspotElement.getBoundingClientRect(), imageRectVis = imageDisplay.getBoundingClientRect();
                        const l_disp = hotspotRectVis.left-imageRectVis.left, t_disp = hotspotRectVis.top-imageRectVis.top,
                              w_disp = hotspotRectVis.width, h_disp = hotspotRectVis.height;
                        const sX = natW/dispW, sY = natH/dispH;
                        const fL=l_disp*sX, fT=t_disp*sY, fW=w_disp*sX, fH=h_disp*sY;
                        hotspot.coords = [Math.round(fL),Math.round(fT),Math.round(fL+fW),Math.round(fT+fH)].join(',');
                        generateTwineCode();
                    }
                }
            } else if (isResizing && activeHotspotElement) {
                isResizing = false;
                const hotspotId = parseInt(activeHotspotElement.dataset.hotspotId);
                const hotspot = hotspots.find(h => h.id === hotspotId);
                if (hotspot) {
                    const natW = imageDisplay.naturalWidth, natH = imageDisplay.naturalHeight,
                          dispW = imageDisplay.offsetWidth, dispH = imageDisplay.offsetHeight;
                    if (dispW && dispH) {
                        const hotspotRectVis = activeHotspotElement.getBoundingClientRect(), imageRectVis = imageDisplay.getBoundingClientRect();
                        const l_disp = hotspotRectVis.left-imageRectVis.left, t_disp = hotspotRectVis.top-imageRectVis.top,
                              w_disp = hotspotRectVis.width, h_disp = hotspotRectVis.height;
                        const sX = natW/dispW, sY = natH/dispH;
                        const fL=l_disp*sX, fT=t_disp*sY, fW=w_disp*sX, fH=h_disp*sY;
                        hotspot.coords = [Math.round(fL),Math.round(fT),Math.round(fL+fW),Math.round(fT+fH)].join(',');
                        generateTwineCode();
                    }
                }
            }
            imageEditor.style.cursor = 'crosshair';
            if(activeHotspotElement && !isDragging && !isResizing) activeHotspotElement.style.cursor = 'move';
            if(!isDragging && !isResizing) activeHotspotElement = null;
        });

        // Function to render hotspots in the image editor and configuration panel
        function renderHotspots() {
            hotspotsContainerEl.innerHTML = ''; // Clear current hotspot configurations
            // Remove visual hotspot elements from the image editor
            document.querySelectorAll('#imageEditor .hotspot-area').forEach(el => { if (el !== currentRect) el.remove(); });
            
            if (hotspots.length === 0) hotspotsContainerEl.innerHTML = '<p>No hi ha hotspots creats.</p>';

            if (imageDisplay.src && imageDisplay.naturalWidth && imageDisplay.naturalHeight) {
                const dispW = imageDisplay.offsetWidth, dispH = imageDisplay.offsetHeight,
                      natW = imageDisplay.naturalWidth, natH = imageDisplay.naturalHeight;
                const imgRectGlob = imageDisplay.getBoundingClientRect(), editorRectGlob = imageEditor.getBoundingClientRect(),
                      offsetXinEd = imgRectGlob.left - editorRectGlob.left, offsetYinEd = imgRectGlob.top - editorRectGlob.top,
                      scaleX = dispW / natW, scaleY = dispH / natH;
                
                hotspots.forEach(hotspot => {
                    const coordsArr = hotspot.coords.split(',').map(Number),
                          visRect = document.createElement('div');
                    visRect.classList.add('hotspot-area');
                    visRect.dataset.hotspotId = hotspot.id;
                    // Position and size visual hotspot based on scaled coordinates
                    visRect.style.left = `${(coordsArr[0] * scaleX) + offsetXinEd}px`;
                    visRect.style.top = `${(coordsArr[1] * scaleY) + offsetYinEd}px`;
                    visRect.style.width = `${(coordsArr[2] - coordsArr[0]) * scaleX}px`;
                    visRect.style.height = `${(coordsArr[3] - coordsArr[1]) * scaleY}px`;

                    // On editor, we don't need to evaluate Harlowe, just display the text as is
                    visRect.addEventListener('mouseenter', () => {
                        let info = '';
                        if (hotspot.type === 'passage' && hotspot.infoText) info = hotspot.infoText;
                        else if (hotspot.type === 'setter' && hotspot.infoTextSetter) info = hotspot.infoTextSetter;
                        if (info) {
                            editorImageInfoDisplay.innerHTML = info.replace(/\n/g, '<br>');
                            editorImageInfoDisplay.style.display = 'block';
                        }
                    });
                    visRect.addEventListener('mouseleave', () => { editorImageInfoDisplay.innerHTML = ''; editorImageInfoDisplay.style.display = 'none'; });

                    // Add click listener to visual hotspot to scroll to its config
                    visRect.addEventListener('click', (e) => {
                        // Prevent this click from bubbling up to the document listener for Twine interaction
                        e.stopPropagation(); 
                        const id = parseInt(e.currentTarget.dataset.hotspotId);
                        const configElement = document.querySelector(`#hotspotsContainer .hotspot-item[data-hotspot-id="${id}"]`);
                        if (configElement) {
                            configElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    });


                    const nameDisplay = document.createElement('div');
                    nameDisplay.classList.add('hotspot-name-display');
                    nameDisplay.textContent = hotspot.name || `Hotspot ${hotspot.id}`;
                    visRect.appendChild(nameDisplay);

                    const delBtn = document.createElement('div');
                    delBtn.classList.add('hotspot-delete-button-visual');
                    delBtn.textContent = 'X'; // Keep it as 'X'
                    delBtn.title = `Eliminar aquest hotspot (${hotspot.name || `Hotspot ${hotspot.id}`})`;
                    delBtn.addEventListener('click', (e) => { e.stopPropagation(); removeHotspot(hotspot.id); });
                    visRect.appendChild(delBtn);

                    // Add resize handle
                    const resizeHandle = document.createElement('div');
                    resizeHandle.classList.add('hotspot-resize-handle');
                    resizeHandle.title = "Redimensionar hotspot";
                    visRect.appendChild(resizeHandle);

                    imageEditor.appendChild(visRect);
                });
            }

            // Render configuration items for each hotspot
            hotspots.forEach(hotspot => {
                const item = document.createElement('div');
                item.classList.add('hotspot-item');
                item.dataset.hotspotId = hotspot.id;

                // Determine placeholder and label text based on hotspot type
                const valueLabelText = hotspot.type === 'passage'
                    ? 'Passatge destí:'
                    : 'Nom de la variable (ex: $nom_variable):'; // Updated label
                const valuePlaceholderText = hotspot.type === 'passage'
                    ? 'Ex: Bosc'
                    : 'Ex: $punts'; // Updated placeholder for variable

                item.innerHTML = `
                    <label>Nom Hotspot:</label><input type="text" data-field="name" value="${hotspot.name || ''}" placeholder="Ex: Porta">
                    <label>Acció:</label><select data-field="type"><option value="passage" ${hotspot.type==='passage'?'selected':''}>Anar Passatge</option><option value="setter" ${hotspot.type==='setter'?'selected':''}>Canviar Variable</option></select>
                    
                    <label class="value-label">${valueLabelText}</label><input type="text" data-field="variable" value="${hotspot.variable || ''}" placeholder="${valuePlaceholderText}">
                    
                    <div class="setter-specific-fields ${hotspot.type==='setter'?'':'hidden-field'}">
                        <label>Valor de la variable:</label><input type="text" data-field="valor" value="${hotspot.valor || ''}" placeholder="Ex: 1000 o &quot;text&quot;">
                    </div>

                    <div class="condition-label-container ${hotspot.type==='passage'?'':'hidden-field'}">
                        <label>Condició:</label>
                        <input type="checkbox" data-field="hasCondition" ${hotspot.hasCondition ? 'checked' : ''}>
                    </div>
                    <div class="condition-fields ${hotspot.hasCondition && hotspot.type === 'passage' ? '' : 'hidden-field'}">
                        <label>Variable (Condició):</label><input type="text" data-field="conditionVariable" value="${hotspot.conditionVariable || ''}" placeholder="Ex: $clau">
                        <label>Valor (Condició):</label><input type="text" data-field="conditionValue" value="${hotspot.conditionValue || ''}" placeholder="Ex: true o 1">
                    </div>
                    <div class="passage-specific-fields ${hotspot.type==='passage'?'':'hidden-field'}">
                        <label>Etiqueta (apareix quan t'atures sobre):</label><input type="text" data-field="titleText" value="${hotspot.titleText || ''}">
                        <label>So (nom de l'àudio registrat a hal.tracks):</label><input type="text" data-field="sound" value="${hotspot.sound || ''}">
                        <label>Info Textual (sota imatge - suporta Harlowe):</label><textarea data-field="infoText">${hotspot.infoText || ''}</textarea>
                    </div>
                    <div class="setter-specific-fields ${hotspot.type==='setter'?'':'hidden-field'}">
                        <label>Etiqueta (apareix quan t'atures sobre):</label><input type="text" data-field="titleTextSetter" value="${hotspot.titleTextSetter || ''}">
                        <label>So (nom de l'àudio registrat a hal.tracks):</label><input type="text" data-field="soundSetter" value="${hotspot.soundSetter || ''}">
                        <label>Info Textual (sota imatge - suporta Harlowe):</label><textarea data-field="infoTextSetter">${hotspot.infoTextSetter || ''}</textarea>
                        <label class="text-alternatiu-label">Text alternatiu (sota imatge - suporta Harlowe):</label><textarea data-field="infoTextSetter2">${hotspot.infoTextSetter2 || ''}</textarea>
                    </div>
                    <button class="delete-config-button">Eliminar ${hotspot.name || `Hotspot ${hotspot.id}`}</button>`;
                hotspotsContainerEl.appendChild(item);

                const pFields = item.querySelector('.passage-specific-fields');
                const sFields = item.querySelector('.setter-specific-fields');
                const vLabel = item.querySelector('.value-label');
                const variableInput = item.querySelector('input[data-field="variable"]'); // Changed from value
                const valorInput = item.querySelector('input[data-field="valor"]'); // New field

                const hasConditionCheckbox = item.querySelector('input[data-field="hasCondition"]');
                const conditionFields = item.querySelector('.condition-fields');
                const conditionLabelContainer = item.querySelector('.condition-label-container');
                const deleteConfigButton = item.querySelector('.delete-config-button');
                const infoTextSetter2Field = item.querySelector('textarea[data-field="infoTextSetter2"]');
                const textAlternatiuLabel = item.querySelector('.text-alternatiu-label');


                // Function to toggle visibility of fields based on hotspot type
                const toggle = type => {
                    pFields.classList.toggle('hidden-field', type !== 'passage');
                    sFields.classList.toggle('hidden-field', type !== 'setter');
                    
                    // Update label and placeholder for the main value/variable input
                    vLabel.textContent = type === 'passage' ? 'Passatge destí:' : 'Nom de la variable (ex: $nom_variable):';
                    variableInput.placeholder = type === 'passage' ? 'Ex: Bosc' : 'Ex: $punts';

                    const isPassageType = type === 'passage';
                    conditionLabelContainer.classList.toggle('hidden-field', !isPassageType);
                    if (!isPassageType) {
                        conditionFields.classList.add('hidden-field');
                        hasConditionCheckbox.checked = false;
                        hotspot.hasCondition = false;
                    } else {
                        conditionFields.classList.toggle('hidden-field', !hotspot.hasCondition);
                    }
                    // Toggle visibility of setter-specific fields
                    const isSetterType = type === 'setter';
                    sFields.classList.toggle('hidden-field', !isSetterType);
                };

                toggle(hotspot.type); // Initial toggle based on current type

                // Event listeners for updating hotspot properties
                item.querySelector('input[data-field="name"]').addEventListener('input', e => {
                    hotspot.name = e.target.value;
                    generateTwineCode();
                    hideCopyFeedback();
                    const hotspotElement = document.querySelector(`.hotspot-area[data-hotspot-id="${hotspot.id}"] .hotspot-name-display`);
                    if (hotspotElement) {
                        hotspotElement.textContent = e.target.value;
                    }
                    // Update the delete button text in the config panel as well
                    deleteConfigButton.textContent = `Eliminar ${e.target.value || `Hotspot ${hotspot.id}`}`;
                });
                item.querySelector('select[data-field="type"]').addEventListener('change', e => {
                    hotspot.type = e.target.value;
                    toggle(hotspot.type);
                    generateTwineCode();
                    hideCopyFeedback();
                });
                // Update event listeners for 'variable' and 'valor'
                ['variable', 'valor', 'titleText','sound','infoText','titleTextSetter','soundSetter','infoTextSetter','infoTextSetter2'].forEach(f => {
                    const element = item.querySelector(`[data-field="${f}"]`);
                    if (element) {
                        element.addEventListener('input', e => {
                            hotspot[f] = e.target.value;
                            generateTwineCode();
                            hideCopyFeedback();
                        });
                    }
                });

                hasConditionCheckbox.addEventListener('change', e => {
                    hotspot.hasCondition = e.target.checked;
                    conditionFields.classList.toggle('hidden-field', !hotspot.hasCondition);
                    generateTwineCode();
                    hideCopyFeedback();
                });

                ['conditionVariable', 'conditionValue'].forEach(f => {
                    const element = item.querySelector(`input[data-field="${f}"]`);
                    if (element) {
                        element.addEventListener('input', e => {
                            hotspot[f] = e.target.value;
                            generateTwineCode();
                            hideCopyFeedback();
                        });
                    }
                });

                item.querySelector('.delete-config-button').addEventListener('click', () => { removeHotspot(hotspot.id); hideCopyFeedback(); });
            });
        }

        // Function to remove a hotspot
        function removeHotspot(id) {
            hotspots = hotspots.filter(h => h.id !== id);
            renderHotspots();
            generateTwineCode();
        }

        // Function to generate Twine (Harlowe) code
        function generateTwineCode() {
            if (!imageDisplay.src || !imageDisplay.naturalWidth || !imageUpload.files || imageUpload.files.length === 0) {
                outputCode.value = "<p>Carrega una imatge per generar el codi.</p>";
                return;
            }
            const originalFileName = imageUpload.files[0].name;
            let twineCode = `<div class="twine-image-wrapper" style="min-width:${imageDisplay.naturalWidth}px;">\n`;
            twineCode += `    <img src="imatges/${originalFileName.replace(/"/g, '&quot;')}" usemap="#hotspotmap" alt="Imatge amb hotspots">\n`;
            twineCode += '    <map name="hotspotmap">\n';
            hotspots.forEach(hotspot => {
                const coords = hotspot.coords;

                const altText = (hotspot.name || `Hotspot ${hotspot.id}`).replace(/"/g, '&quot;');
                let areaTag = `        <area shape="rect" coords="${coords}" alt="${altText}" class="hotspot-item"`;
                if (hotspot.type === 'passage') {
                    if (hotspot.value) areaTag += ` data-passage="${hotspot.value.replace(/"/g, '&quot;')}"`;
                    if (hotspot.titleText) areaTag += ` title="${hotspot.titleText.replace(/"/g, '&quot;')}"`;
                    if (hotspot.sound) areaTag += ` data-sound="${hotspot.sound.replace(/"/g, '&quot;')}"`;
                    if (hotspot.infoText) areaTag += ` data_info="${hotspot.infoText.replace(/"/g, '&quot;')}"`;

                    if (hotspot.hasCondition) {
                        if (hotspot.conditionVariable) areaTag += ` data-condition-var="${hotspot.conditionVariable.replace(/"/g, '&quot;')}"`;
                        if (hotspot.conditionValue) areaTag += ` data-condition-val="${hotspot.conditionValue.replace(/"/g, '&quot;')}"`;
                    }
                } else if (hotspot.type === 'setter') {
                    let setMacroContent = '';
                    const valorRaw = hotspot.valor;
                    const valorTrimmed = valorRaw.trim();
                    const arithmeticOperators = ['+', '-', '*', '/', '%'];
                    const startsWithArithmeticOperator = arithmeticOperators.some(op => valorTrimmed.startsWith(op));
                    const hasOtherOperator = ['>', '<', 'is', '=', 'to'].some(op => valorTrimmed.startsWith(op));

                    if (hotspot.variable) {
                        let formattedValorForMacro = valorTrimmed;
                        
                        if (startsWithArithmeticOperator) {
                            // If it starts with an arithmetic operator, format it as an operation
                            // Example: "$diners += 100"
                            setMacroContent = `${hotspot.variable} ${valorTrimmed}`; // e.g., $var += 50
                        } else if (!isNaN(valorTrimmed) && valorTrimmed !== '') {
                            // It's a simple number, assign directly
                            setMacroContent = `${hotspot.variable} = ${valorTrimmed}`;
                        } else {
                            // It's a string literal or has other operators, quote it if it's a simple string
                            if (!hasOtherOperator) { // Only quote if it's a plain string, not already a complex expression
                                formattedValorForMacro = `"${valorTrimmed.replace(/"/g, '\\"')}"`;
                            }
                            setMacroContent = `${hotspot.variable} = ${formattedValorForMacro}`;
                        }
                    }
                    
                    // The data-setter attribute should have quotes escaped for HTML
                    if (setMacroContent) areaTag += ` data-setter="${setMacroContent.replace(/"/g, '&quot;')}"`;
                    if (hotspot.titleTextSetter) areaTag += ` title="${hotspot.titleTextSetter.replace(/"/g, '&quot;')}"`;
                    if (hotspot.soundSetter) areaTag += ` data-sound="${hotspot.soundSetter.replace(/"/g, '&quot;')}"`;
                    if (hotspot.infoTextSetter) areaTag += ` data_info="${hotspot.infoTextSetter.replace(/"/g, '&quot;')}"`;
                    if (hotspot.infoTextSetter2) areaTag += ` data_info_2="${hotspot.infoTextSetter2.replace(/"/g, '&quot;')}"`;
                    
                    // Store variable and valor as raw strings (no HTML escaping here)
                    if (hotspot.variable) areaTag += ` data_variable="${hotspot.variable}"`;
                    if (hotspot.valor) areaTag += ` data_valor="${hotspot.valor}"`;
                }
                areaTag += '>\n';
                twineCode += areaTag;
            });
            twineCode += '    </map>\n';
            twineCode += `    <div id="twineImageInfoDisplay" style="display: none;">(live: 0.1s)[(print: $tempInfoDisplay)]</div>\n`;
            twineCode += '</div>\n\n';

            // Generate Harlowe links for passages (setters no longer need hidden links)
            twineCode += '(live: 0.1s)[\n';
            twineCode += '    <span id="Ocult" style="display:none;">\n';
            hotspots.forEach(hotspot => {
                if (hotspot.type === 'passage' && hotspot.value) {
                    const passageNameForLink = hotspot.value.replace(/"/g, '\\"');
                    let harloweLink = '';

                    if (hotspot.hasCondition && hotspot.conditionVariable && hotspot.conditionValue) {
                        let conditionValueFormatted = hotspot.conditionValue;
                        // Add 'is' for numerical conditions if no operator is present
                        const startsWithOperator = ['>', '<', 'is', '=', 'not', 'contains'].some(op => conditionValueFormatted.trim().startsWith(op));
                        if (!isNaN(conditionValueFormatted) && !startsWithOperator && conditionValueFormatted.trim() !== '') {
                            conditionValueFormatted = `is ${conditionValueFormatted}`;
                        } else if (isNaN(conditionValueFormatted) && !startsWithOperator && conditionValueFormatted.trim() !== '') {
                            conditionValueFormatted = `is "${conditionValueFormatted.replace(/"/g, '\\"')}"`;
                        }
                        harloweLink = `    (if: ${hotspot.conditionVariable} ${conditionValueFormatted})[(link: "${passageNameForLink}")[(goto: "${passageNameForLink}")]]`;
                    } else {
                        harloweLink = `    (link: "${passageNameForLink}")[(goto: "${passageNameForLink}")]`;
                    }
                    twineCode += `${harloweLink}\n`;
                }
                // Removed setter link generation here
            });
            twineCode += '    </span>\n';
            twineCode += ']\n';

            outputCode.value = twineCode;
        }

        // Event listener for copy code button
        copyCodeButton.addEventListener('click', () => {
            outputCode.select(); // Select the text in the textarea
            document.execCommand('copy'); // Copy to clipboard
            copyFeedback.classList.add('show'); // Show feedback message
        });

        // Event listener for load code button
        loadCodeButton.addEventListener('click', () => {
            hideCopyFeedback(); // Hide feedback on load
            const codeToParse = outputCode.value;
            if (codeToParse.trim() === "") {
                alert("El camp de codi està buit. Enganxa el codi HTML/Harlowe per carregar.");
                return;
            }
            parseTwineCode(codeToParse);
        });

        // Function to parse existing Twine code and populate the editor
        function parseTwineCode(code) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(code, 'text/html'); // Parse into a full document

            const imgElement = doc.querySelector('.twine-image-wrapper img[usemap]'); // Be more specific
            if (!imgElement) {
                alert("No s'ha trobat cap etiqueta <img> amb usemap dins de .twine-image-wrapper.");
                return;
            }

            const mapName = imgElement.getAttribute('usemap').substring(1); // Get map name without '#'
            const mapElement = doc.querySelector(`map[name="${mapName}"]`);

            if (!mapElement) {
                alert(`No s'ha trobat l'etiqueta <map name="${mapName}"> associada a la imatge.`);
                return;
            }

            // Reset hotspots and counter
            hotspots = [];
            let maxHotspotId = 0;
            const areaElements = mapElement.querySelectorAll('area'); // Query areas directly from the map
            areaElements.forEach(area => {
                const coords = area.getAttribute('coords');
                const altText = area.getAttribute('alt');
                const dataPassage = area.getAttribute('data-passage');
                const dataSetter = area.getAttribute('data-setter'); // This will be the combined string
                const title = area.getAttribute('title');
                const dataSound = area.getAttribute('data-sound');
                const dataInfo = area.getAttribute('data_info');
                const dataInfo2 = area.getAttribute('data_info_2');

                // New attributes for setter variable and value
                const dataVariable = area.getAttribute('data_variable');
                const dataValor = area.getAttribute('data_valor');

                const dataConditionVar = area.getAttribute('data-condition-var');
                const dataConditionVal = area.getAttribute('data-condition-val');

                hotspotIdCounter++;
                maxHotspotId = Math.max(maxHotspotId, hotspotIdCounter);

                let newHotspot = {
                    id: hotspotIdCounter,
                    coords: coords,
                    name: altText || `Hotspot ${hotspotIdCounter}`,
                    type: 'passage',
                    value: '', // For passage type
                    titleText: '',
                    sound: '',
                    infoText: '',
                    variable: '', // For setter type
                    valor: '', // For setter type
                    titleTextSetter: '',
                    soundSetter: '',
                    infoTextSetter: '',
                    infoTextSetter2: '',
                    hasCondition: false,
                    conditionVariable: '',
                    conditionValue: ''
                };
                if (dataPassage) {
                    newHotspot.type = 'passage';
                    newHotspot.value = dataPassage;
                    newHotspot.titleText = title || '';
                    newHotspot.sound = dataSound || '';
                    newHotspot.infoText = dataInfo || '';
                    newHotspot.hasCondition = !!dataConditionVar;
                    newHotspot.conditionVariable = dataConditionVar || '';
                    newHotspot.conditionValue = dataConditionVal || '';
                } else if (dataSetter) { // If data-setter exists, it's a setter type
                    newHotspot.type = 'setter';
                    // Load variable and valor from new dedicated attributes (they are now stored raw)
                    newHotspot.variable = dataVariable || '';
                    newHotspot.valor = dataValor || '';
                    newHotspot.titleTextSetter = title || '';
                    newHotspot.soundSetter = dataSound || '';
                    newHotspot.infoTextSetter = dataInfo || '';
                    newHotspot.infoTextSetter2 = dataInfo2 || '';
                }
                hotspots.push(newHotspot);
            });
            hotspotIdCounter = maxHotspotId;

            renderHotspots();
            generateTwineCode();
        }

        // Initial rendering and code generation on page load
        renderHotspots();
        generateTwineCode();
        // Add event listener for window resize to re-render hotspots
        window.addEventListener('resize', renderHotspots);
        
        // --- NEW JAVASCRIPT FOR HOTSPOT INTERACTION ---
        document.addEventListener('click', (e) => {
            if (e.target.tagName === 'AREA' && e.target.classList.contains('hotspot-item')) {
                const hotspotName = e.target.getAttribute('alt'); // Get the alt text (hotspot name)
                const dataSound = e.target.getAttribute('data-sound');
                const dataInfo = e.target.getAttribute('data_info');
                const dataInfo2 = e.target.getAttribute('data_info_2');

                // Update info display based on data_info or data_info_2
                const twineInfoDisplay = document.getElementById('twineImageInfoDisplay');
                if (twineInfoDisplay) {
                    // Harlowe.set() requires the variable to be declared in Twine, e.g., (set: $tempInfoDisplay to "")
                    // This will update the variable, and the (print:) macro in Twine will display it.
                    if (dataInfo) {
                        window.Harlowe.set('$tempInfoDisplay', dataInfo);
                        twineInfoDisplay.style.display = 'block';
                    } else if (dataInfo2) {
                        window.Harlowe.set('$tempInfoDisplay', dataInfo2);
                        twineInfoDisplay.style.display = 'block';
                    } else {
                        twineInfoDisplay.style.display = 'none';
                        window.Harlowe.set('$tempInfoDisplay', ''); // Clear the display if no info
                    }
                }

                // Play sound if available (assuming hal.tracks is defined in Twine)
                if (dataSound && window.hal && window.hal.tracks && window.hal.tracks[dataSound]) {
                    window.hal.tracks[dataSound].play();
                }

                // Determine action based on hotspot type
                if (e.target.hasAttribute('data-passage')) {
                    // This is a passage link, find and click the hidden Harlowe link
                    const linksInOcult = document.querySelectorAll('#Ocult a');
                    let foundLink = null;
                    for (let i = 0; i < linksInOcult.length; i++) {
                        if (linksInOcult[i].textContent.trim() === hotspotName) {
                            foundLink = linksInOcult[i];
                            break;
                        }
                    }

                    if (foundLink) {
                        foundLink.click(); // Programmatically click the link
                    } else {
                        console.warn(`No s'ha trobat el link de Harlowe ocult per al hotspot de passatge: ${hotspotName}`);
                    }
                } else if (e.target.hasAttribute('data_variable') && e.target.hasAttribute('data_valor')) {
                    // This is a setter, directly use window.Harlowe.set()
                    const variableName = e.target.getAttribute('data_variable');
                    const rawValue = e.target.getAttribute('data_valor');
                    
                    if (!variableName || typeof window.Harlowe === 'undefined' || typeof window.Harlowe.set !== 'function' || typeof window.Harlowe.get !== 'function') {
                        console.warn(`No s'ha pogut actualitzar la variable de Twine. Harlowe.set/get no disponible o variableName invàlid.`);
                        return;
                    }

                    const trimmedRawValue = rawValue === null ? "" : rawValue.trim();
                    const arithmeticOperators = ['+', '-', '*', '/', '%'];
                    const startsWithArithmeticOperator = arithmeticOperators.some(op => trimmedRawValue.startsWith(op));

                    if (startsWithArithmeticOperator) {
                        // Handle arithmetic operations
                        const operator = trimmedRawValue.charAt(0);
                        const operandStr = trimmedRawValue.substring(1).trim();
                        const operand = Number(operandStr);

                        if (!isNaN(operand)) {
                            let currentValue = Number(window.Harlowe.get(variableName)); // Explicitly convert to number

                            // Ensure current value is a number for arithmetic operations, initialize to 0 if not
                            if (isNaN(currentValue)) {
                                console.warn(`La variable '${variableName}' no és un número. S'inicialitza a 0 per realitzar l'operació aritmètica.`);
                                window.Harlowe.set(variableName, 0); // Initialize to 0
                                currentValue = 0; // Use 0 for the current operation
                            }

                            let newValue;
                            switch (operator) {
                                case '+': newValue = currentValue + operand; break;
                                case '-': newValue = currentValue - operand; break;
                                case '*': newValue = currentValue * operand; break;
                                case '/': 
                                    if (operand === 0) {
                                        console.warn(`Divisió per zero en la variable '${variableName}'.`);
                                        return;
                                    }
                                    newValue = currentValue / operand; 
                                    break;
                                case '%': 
                                    if (operand === 0) {
                                        console.warn(`Mòdul per zero en la variable '${variableName}'.`);
                                        return;
                                    }
                                    newValue = currentValue % operand; 
                                    break;
                                default:
                                    console.warn(`Operador aritmètic desconegut: ${operator}`);
                                    return;
                            }
                            window.Harlowe.set(variableName, newValue);
                            console.log(`Variable de Twine '${variableName}' actualitzada aritmèticament a:`, newValue);
                        } else {
                            console.warn(`Operand invàlid per a l'operació aritmètica: ${operandStr}`);
                        }
                    } else {
                        // Handle direct assignment (number or string)
                        let parsedValue;
                        if (!isNaN(trimmedRawValue) && trimmedRawValue !== '') {
                            parsedValue = Number(trimmedRawValue);
                        } else {
                            // It's a string. Check if it's explicitly quoted by the user and remove outer quotes.
                            if (trimmedRawValue.startsWith('"') && trimmedRawValue.endsWith('"') && trimmedRawValue.length > 1) {
                                parsedValue = trimmedRawValue.substring(1, trimmedRawValue.length - 1);
                            } else {
                                parsedValue = trimmedRawValue;
                            }
                        }
                        window.Harlowe.set(variableName, parsedValue);
                        console.log(`Variable de Twine '${variableName}' actualitzada a:`, parsedValue);
                    }
                }
            }
        });
        // --- END NEW JAVASCRIPT ---
    </script>
</body>
</html>
