<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Hotspots per Twine (Harlowe)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .panel {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #imageEditor {
            flex: 2;
            min-width: 400px;
            position: relative;
            cursor: crosshair;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 0;
            height: auto;
            min-height: 400px;
            border: 1px dashed #ccc;
            overflow: hidden; /* Important per controlar el desbordament visual */
            box-sizing: border-box; /* Per incloure padding i border en el width/height */
        }
        #imageDisplay {
            max-width: 100%;
            height: auto;
            display: none;
            user-select: none; /* Evita que la imatge es pugui seleccionar amb el ratolí */
            -webkit-user-drag: none; /* Evita que la imatge es pugui arrossegar */
        }
        #drawingInstructions {
            text-align: center;
            margin-top: 50px;
            color: #666;
        }
        .hotspot-area {
            position: absolute;
            border: 2px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.2);
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            font-size: 14px;
            box-sizing: border-box;
            z-index: 5; /* Base z-index for the hotspot area */
        }
        .hotspot-name-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 2px 5px;
            background: rgba(0,0,0,0.7);
            border-radius: 3px;
            white-space: nowrap;
            pointer-events: none; /* Permet el clic a través del nom */
            z-index: 15; /* Higher z-index to be above the hotspot area */
        }
        .hotspot-area:hover {
            background-color: rgba(0, 123, 255, 0.4);
        }
        #hotspotsConfig {
            flex: 1;
            min-width: 300px;
        }
        .hotspot-item {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px; /* Increased margin-bottom for spacing between hotspot items */
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .hotspot-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .hotspot-item input[type="text"],
        .hotspot-item select,
        .hotspot-item textarea,
        .hotspot-item input[type="number"] { /* Added number type */
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px; /* Kept existing margin-bottom for input fields */
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .hotspot-item textarea {
            resize: vertical;
            min-height: 60px;
        }
        .hotspot-item button.delete-config-button {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            /* float: right; Removed float */
            margin-top: 20px; /* Added margin-top to separate from previous fields */
            display: block; /* Make it a block element */
            margin-left: auto; /* Center the button */
            margin-right: auto; /* Center the button */
            width: fit-content; /* Adjust width to content */
        }
        .hotspot-item button.delete-config-button:hover {
            background-color: #c82333;
        }
        #outputCode {
            width: calc(100% - 40px);
            height: 300px;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #e9ecef;
            resize: vertical;
        }
        .button-group {
            margin-top: 10px;
        }
        .button-group button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        .button-group button:hover {
            background-color: #0056b3;
        }
        #copyFeedback {
            display: none;
            margin-left: 10px;
            color: green;
            font-weight: bold;
        }
        .hotspot-delete-button-visual {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #dc3545;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            z-index: 20; /* Even higher z-index to be above the hotspot area */
        }
        .hotspot-delete-button-visual:hover {
            background-color: #c82333;
        }
        /* Styles for the resize handle */
        .hotspot-resize-handle {
            position: absolute;
            bottom: -5px; /* Adjust to position slightly outside */
            right: -5px; /* Adjust to position slightly outside */
            width: 10px;
            height: 10px;
            background-color: white;
            border: 1px solid #007bff;
            border-radius: 50%;
            cursor: nwse-resize; /* Diagonal resize cursor */
            z-index: 25; /* Higher than delete button and name display */
        }
        .hidden-field {
            display: none;
        }
        #editorImageInfoDisplay {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 1em;
            display: none;
            z-index: 100; /* Assegura que estigui per sobre de tot */
            pointer-events: none; /* No interfereix amb els clics */
        }
        /* New styles for condition labels */
        .condition-label-container label,
        .column label { /* Changed to target all labels in columns */
            color: #333; /* Default color for all labels */
        }
        .column .condition-label { /* Specific class for condition labels */
            color: darkred; /* Dark red for condition labels */
        }
        .column .limit-label { /* Specific class for limit labels */
            color: darkorange; /* Dark orange for limit labels */
        }
        .column .darkblue-label { /* NEW: Specific class for dark blue labels */
            color: darkblue; /* Dark blue for the new labels */
        }

        /* Styles for section separation */
        .hotspot-section {
            margin-bottom: 10px; /* Space between sections */
            padding-bottom: 10px; /* Padding before the border */
            border-bottom: 1px dashed #e0e0e0; /* Dashed line for separation */
        }

        .hotspot-section:last-of-type {
            border-bottom: none; /* No border for the last section */
            padding-bottom: 0;
            margin-bottom: 0;
        }

        /* New styles for two-column layout */
        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px; /* Space between columns */
            margin-top: 15px;
        }

        .column {
            display: flex;
            flex-direction: column;
        }
        /* Specific style for condition fields to stack vertically */
        .condition-inputs-wrapper {
            display: block !important; /* Override flex to stack */
        }
        .condition-inputs-wrapper label,
        .condition-inputs-wrapper input,
        .condition-inputs-wrapper textarea {
            margin-bottom: 10px; /* Add space between stacked elements */
        }
        /* Style for the checkbox container to ensure proper alignment */
        .secondary-variable-toggle-container,
        .condition-toggle-container { /* Added condition-toggle-container */
            margin-top: 10px; /* Space above the checkbox */
            margin-bottom: 10px; /* Space below the checkbox */
        }
        .secondary-variable-toggle-container label,
        .condition-toggle-container label { /* Added condition-toggle-container */
            display: flex;
            align-items: center;
            font-weight: bold;
        }
        .secondary-variable-toggle-container input[type="checkbox"],
        .condition-toggle-container input[type="checkbox"] { /* Added condition-toggle-container */
            margin-right: 8px; /* Space between checkbox and label text */
            width: auto; /* Reset width for checkbox */
            margin-bottom: 0; /* Remove bottom margin for checkbox */
        }
        .strong-red-label {
            color: #8B0000; /* Darker red */
        }
    </style>
</head>
<body>
    <h1>Editor de Hotspots per a Històries de Twine (Harlowe)</h1>
    <p>1. Carrega una imatge. 2. Dibuixa rectangles sobre les àrees que vulguis fer interactives. 3. Configura cada hotspot. 4. Copia el codi generat i enganxa'l al passatge de Twine.</p>

    <div class="container">
        <div class="panel" id="imageConfig">
            <h2>Configuració de la Imatge</h2>
            <label for="imageUpload">Carregar Imatge:</label>
            <input type="file" id="imageUpload" accept="image/*">
            <div id="imageEditor">
                <img id="imageDisplay" src="" alt="Imatge de la història" style="display: none;">
                <p id="drawingInstructions">Carrega una imatge i dibuixa un hotspot!</p>
                <div id="editorImageInfoDisplay"></div>
            </div>
        </div>

        <div class="panel" id="hotspotsConfig">
            <h2>Hotspots Configurats</h2>
            <div id="hotspotsContainer">
                <p>No hi ha hotspots creats.</p>
            </div>
        </div>
    </div>

    <div class="panel">
        <h2>Codi Twine (Harlowe) Generat</h2>
        <textarea id="outputCode"></textarea>
        <div class="button-group">
            <button id="copyCodeButton">Copiar Codi</button>
            <button id="loadCodeButton">Carregar Codi existent</button>
            <span id="copyFeedback">Codi copiat!</span>
        </div>
    </div>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const imageDisplay = document.getElementById('imageDisplay');
        const imageEditor = document.getElementById('imageEditor');
        const hotspotsContainerEl = document.getElementById('hotspotsContainer');
        const outputCode = document.getElementById('outputCode');
        const copyCodeButton = document.getElementById('copyCodeButton');
        const drawingInstructions = document.getElementById('drawingInstructions');
        const editorImageInfoDisplay = document.getElementById('editorImageInfoDisplay');
        const copyFeedback = document.getElementById('copyFeedback');
        const loadCodeButton = document.getElementById('loadCodeButton');

        let isDrawing = false;
        let isDragging = false;
        let isResizing = false; // New state for resizing
        let activeHotspotElement = null;
        let dragOffsetX, dragOffsetY;
        let initialHotspotWidth, initialHotspotHeight; // New variables for resizing
        let initialMouseX, initialMouseY; // New variables for resizing
        let startX, startY;
        let currentRect = null;
        let hotspots = [];
        let hotspotIdCounter = 0;
        let hasMovedDuringInteraction = false; // New flag to track if mouse moved during mousedown

        // Function to hide the "Code copied!" feedback
        function hideCopyFeedback() {
            copyFeedback.classList.remove('show');
        }

        // Event listener for image upload
        imageUpload.addEventListener('change', (e) => {
            hideCopyFeedback(); // Hide feedback on new image upload
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    imageDisplay.src = event.target.result;
                    imageDisplay.style.display = 'block';
                    drawingInstructions.style.display = 'none';
                    editorImageInfoDisplay.style.display = 'none';

                    imageDisplay.onload = () => {
                        // Adjust image editor height based on image dimensions
                        const extraSpace = 80;
                        imageEditor.style.minHeight = imageDisplay.offsetHeight + extraSpace + 'px';
                        imageEditor.style.height = imageDisplay.offsetHeight + extraSpace + 'px';
                        hotspots = []; // Clear existing hotspots when a new image is loaded
                        renderHotspots();
                        generateTwineCode();
                    };
                    imageDisplay.onerror = () => {
                        // Handle image loading errors
                        alert("Error al carregar la imatge.");
                        imageDisplay.src = '';
                        imageDisplay.style.display = 'none';
                        drawingInstructions.style.display = 'block';
                        editorImageInfoDisplay.style.display = 'none';
                    }
                };
                reader.readAsDataURL(file);
            } else {
                // Reset display if no file is selected
                imageDisplay.src = '';
                imageDisplay.style.display = 'none';
                drawingInstructions.style.display = 'block';
                imageEditor.style.height = 'auto';
                imageEditor.style.minHeight = '400px';
                hotspots = [];
                renderHotspots();
                generateTwineCode();
            }
        });

        // Mouse down event listener for image editor (drawing, dragging, and resizing)
        imageEditor.addEventListener('mousedown', (e) => {
            hideCopyFeedback(); // Hide feedback on interaction
            if (imageDisplay.style.display === 'none' || !imageDisplay.src) return; // Only interact if an image is loaded
            if (e.target.classList.contains('hotspot-delete-button-visual')) return; // Ignore clicks on delete button

            hasMovedDuringInteraction = false; // Reset flag at the start of a new interaction

            if (e.target.classList.contains('hotspot-resize-handle')) {
                isResizing = true;
                activeHotspotElement = e.target.parentElement; // Get the parent hotspot-area
                initialHotspotWidth = activeHotspotElement.offsetWidth;
                initialHotspotHeight = activeHotspotElement.offsetHeight;
                initialMouseX = e.clientX;
                initialMouseY = e.clientY;
                activeHotspotElement.style.cursor = 'nwse-resize'; // Keep resize cursor
                e.stopPropagation(); // Prevent drawing or dragging the hotspot
            } else if (e.target.classList.contains('hotspot-area')) {
                isDragging = true;
                activeHotspotElement = e.target;
                const hotspotRect = activeHotspotElement.getBoundingClientRect();
                dragOffsetX = e.clientX - hotspotRect.left;
                dragOffsetY = e.clientY - hotspotRect.top;
                activeHotspotElement.style.cursor = 'grabbing';
                e.stopPropagation();
            } else if (imageEditor.contains(e.target) && (e.target === imageDisplay || e.target === imageEditor || e.target.parentElement === imageEditor || e.target.parentElement.parentElement === imageEditor ) ) {
                isDrawing = true;
                const imageRect = imageDisplay.getBoundingClientRect();
                startX = e.clientX - imageRect.left;
                startY = e.clientY - imageRect.top;
                currentRect = document.createElement('div');
                currentRect.classList.add('hotspot-area');
                const editorRect = imageEditor.getBoundingClientRect();
                currentRect.style.left = `${e.clientX - editorRect.left}px`;
                currentRect.style.top = `${e.clientY - editorRect.top}px`;
                currentRect.style.width = '0px';
                currentRect.style.height = '0px';
                currentRect.style.cursor = 'crosshair';
                imageEditor.appendChild(currentRect);
                imageEditor.style.cursor = 'grabbing';
            }
        });

        // Mouse move event listener for drawing, dragging, and resizing
        document.addEventListener('mousemove', (e) => {
            if (isDrawing && currentRect) {
                hasMovedDuringInteraction = true; // Mouse moved during drawing
                // Update dimensions of the new hotspot being drawn
                const imageRect = imageDisplay.getBoundingClientRect(), editorRect = imageEditor.getBoundingClientRect();
                let currentMouseEventX_onImage = e.clientX - imageRect.left, currentMouseEventY_onImage = e.clientY - imageRect.top;
                let rLeft = Math.min(startX, currentMouseEventX_onImage), rTop = Math.min(startY, currentMouseEventY_onImage),
                    rRight = Math.max(startX, currentMouseEventX_onImage), rBottom = Math.max(startY, currentMouseEventY_onImage);
                
                // Clamp coordinates to image boundaries
                rLeft = Math.max(0, rLeft);
                rTop = Math.max(0, rTop);
                rRight = Math.min(imageRect.width, rRight);
                rBottom = Math.min(imageRect.height, rBottom);
                
                let rWidth = rRight - rLeft, rHeight = rBottom - rTop;

                if (rWidth < 0) rWidth = 0;
                if (rHeight < 0) rHeight = 0;

                currentRect.style.left = `${(imageRect.left - editorRect.left) + rLeft}px`;
                currentRect.style.top = `${(imageRect.top - editorRect.top) + rTop}px`;
                currentRect.style.width = `${rWidth}px`;
                currentRect.style.height = `${rHeight}px`;
            } else if (isDragging && activeHotspotElement) {
                hasMovedDuringInteraction = true; // Mouse moved during dragging
                // Update position of the dragged hotspot
                const imageRect = imageDisplay.getBoundingClientRect(), editorRect = imageEditor.getBoundingClientRect();
                let newLeftInEditor = e.clientX - editorRect.left - dragOffsetX, newTopInEditor = e.clientY - editorRect.top - dragOffsetY;
                const hotspotWidth = activeHotspotElement.offsetWidth, hotspotHeight = activeHotspotElement.offsetHeight,
                      imageLeftInEditor = imageRect.left - editorRect.left, imageTopInEditor = imageRect.top - editorRect.top,
                      imageRightInEditor = imageLeftInEditor + imageRect.width, imageBottomInEditor = imageTopInEditor + imageRect.height;
                
                // Clamp hotspot position to image boundaries
                newLeftInEditor = Math.max(imageLeftInEditor, Math.min(newLeftInEditor, imageRightInEditor - hotspotWidth));
                newTopInEditor = Math.max(imageTopInEditor, Math.min(newTopInEditor, imageBottomInEditor - hotspotHeight));
                
                activeHotspotElement.style.left = `${newLeftInEditor}px`;
                activeHotspotElement.style.top = `${newTopInEditor}px`;
            } else if (isResizing && activeHotspotElement) {
                hasMovedDuringInteraction = true; // Mouse moved during resizing
                const imageRect = imageDisplay.getBoundingClientRect(), editorRect = imageEditor.getBoundingClientRect();
                const imageLeftInEditor = imageRect.left - editorRect.left;
                const imageTopInEditor = imageRect.top - editorRect.top;
                const imageRightInEditor = imageLeftInEditor + imageRect.width;
                const imageBottomInEditor = imageTopInEditor + imageRect.height;

                let newWidth = initialHotspotWidth + (e.clientX - initialMouseX);
                let newHeight = initialHotspotHeight + (e.clientY - initialMouseY);

                // Get current position of the hotspot
                const currentLeft = parseFloat(activeHotspotElement.style.left);
                const currentTop = parseFloat(activeHotspotElement.style.top);

                // Clamp new width/height to image boundaries and minimum size (e.g., 5px)
                newWidth = Math.max(5, Math.min(newWidth, imageRightInEditor - currentLeft));
                newHeight = Math.max(5, Math.min(newHeight, imageBottomInEditor - currentTop));

                activeHotspotElement.style.width = `${newWidth}px`;
                activeHotspotElement.style.height = `${newHeight}px`;
            }
        });

        // Mouse up event listener for finishing drawing, dragging, or resizing
        document.addEventListener('mouseup', (e) => {
            if (isDrawing && currentRect) {
                // Finish drawing a new hotspot
                isDrawing = false;
                const natW = imageDisplay.naturalWidth, natH = imageDisplay.naturalHeight,
                      dispW = imageDisplay.offsetWidth, dispH = imageDisplay.offsetHeight;

                const hotspotRectVis = currentRect.getBoundingClientRect(), imageRectVis = imageDisplay.getBoundingClientRect();
                let l_disp = hotspotRectVis.left - imageRectVis.left, t_disp = hotspotRectVis.top - imageRectVis.top,
                    w_disp = hotspotRectVis.width, h_disp = hotspotRectVis.height;
                currentRect.remove(); // Remove the temporary drawing rectangle
                currentRect = null;

                if (w_disp >= 5 && h_disp >= 5 && dispW && dispH) { // Only add if it's a reasonable size
                    const sX = natW / dispW, sY = natH / dispH;
                    const fL = l_disp * sX, fT = t_disp * sY, fW = w_disp * sX, fH = h_disp * sY;

                    const coords = [Math.round(fL),Math.round(fT),Math.round(fL+fW),Math.round(fT+fH)].join(',');
                    hotspotIdCounter++;
                    hotspots.push({
                        id: hotspotIdCounter,
                        coords: coords,
                        name: `Hotspot ${hotspotIdCounter}`,
                        type: 'passage',
                        value: '', // For passage type
                        titleText: '',
                        sound: '', // Initialize sound property
                        infoText: '', // This field will now store the Harlowe text (mouse enter)
                        infoText2: '', // NEW: For passage click info text
                        transition: '', // NEW: For passage transition
                        variable: '', // New field for setter variable name
                        valor: '', // New field for setter variable value
                        titleTextSetter: '',
                        soundSetter: '', // Initialize soundSetter property
                        infoTextSetter: '', // This field will now store the Harlowe text (mouse enter)
                        infoTextSetter2: '', // New field for alternative info text for setter (click)
                        
                        // Passage specific condition fields
                        passageConditionVariable: '',
                        passageConditionValue: '',
                        passageFailInfo: '',
                        passageFailInfoEnter: '',
                        passageSoundFail: '',

                        // Setter specific condition fields
                        setterConditionVariable: '',
                        setterConditionValue: '',
                        setterFailInfo: '',
                        setterFailInfoEnter: '',
                        setterSoundFail: '',

                        // Visit Limit fields (common for both types)
                        visitLimit: '',
                        visitLimitTextEnter: '',
                        visitLimitTextClic: '',

                        // Secondary Setter fields
                        variable2: '',
                        valor2: '',
                        enableSecondaryVariable: false, // Default to false
                        enableConditionVariable: false // Default to false
                    });
                }
                renderHotspots();
                generateTwineCode();
            } else if (isDragging && activeHotspotElement) {
                isDragging = false;
                const hotspotId = parseInt(activeHotspotElement.dataset.hotspotId);
                const hotspot = hotspots.find(h => h.id === hotspotId);
                if (hotspot) {
                    const natW = imageDisplay.naturalWidth, natH = imageDisplay.naturalHeight,
                          dispW = imageDisplay.offsetWidth, dispH = imageDisplay.offsetHeight;
                    if (dispW && dispH) {
                        const hotspotRectVis = activeHotspotElement.getBoundingClientRect(), imageRectVis = imageDisplay.getBoundingClientRect();
                        const l_disp = hotspotRectVis.left-imageRectVis.left, t_disp = hotspotRectVis.top-imageRectVis.top,
                              w_disp = hotspotRectVis.width, h_disp = hotspotRectVis.height;
                        const sX = natW/dispW, sY = natH/dispH;
                        const fL=l_disp*sX, fT=t_disp*sY, fW=w_disp*sX, fH=h_disp*sY;
                        hotspot.coords = [Math.round(fL),Math.round(fT),Math.round(fL+fW),Math.round(fT+fH)].join(',');
                        generateTwineCode();
                    }
                }
            } else if (isResizing && activeHotspotElement) {
                isResizing = false;
                const hotspotId = parseInt(activeHotspotElement.dataset.hotspotId);
                const hotspot = hotspots.find(h => h.id === hotspotId);
                if (hotspot) {
                    const natW = imageDisplay.naturalWidth, natH = imageDisplay.naturalHeight,
                          dispW = imageDisplay.offsetWidth, dispH = imageDisplay.offsetHeight;
                    if (dispW && dispH) {
                        const hotspotRectVis = activeHotspotElement.getBoundingClientRect(), imageRectVis = imageDisplay.getBoundingClientRect();
                        const l_disp = hotspotRectVis.left-imageRectVis.left, t_disp = hotspotRectVis.top-imageRectVis.top,
                              w_disp = hotspotRectVis.width, h_disp = hotspotRectVis.height;
                        const sX = natW/dispW, sY = natH/dispH;
                        const fL=l_disp*sX, fT=t_disp*sY, fW=w_disp*sX, fH=h_disp*sY;
                        hotspot.coords = [Math.round(fL),Math.round(fT),Math.round(fL+fW),Math.round(fT+fH)].join(',');
                        generateTwineCode();
                    }
                }
            }
            imageEditor.style.cursor = 'crosshair';
            if(activeHotspotElement && !isDragging && !isResizing) activeHotspotElement.style.cursor = 'move';
            if(!isDragging && !isResizing) activeHotspotElement = null;
        });

        // Function to update visibility of inner fields (secondary variable, condition, visit limit)
        function updateInnerFieldVisibility(hotspot, itemElement) {
            // Get both sections
            const passageSection = itemElement.querySelector('.passage-specific-fields');
            const setterSection = itemElement.querySelector('.setter-specific-fields');

            // Process Passage section if it exists
            if (passageSection) {
                const secondaryFieldsContainer = passageSection.querySelector('.secondary-variable-fields');
                const enableSecondaryCheckbox = passageSection.querySelector('[data-field="enableSecondaryVariable"]');
                if (secondaryFieldsContainer && enableSecondaryCheckbox) {
                    secondaryFieldsContainer.classList.toggle('hidden-field', !hotspot.enableSecondaryVariable);
                    enableSecondaryCheckbox.checked = hotspot.enableSecondaryVariable; // Sync checkbox state
                }

                const conditionFieldsContainer = passageSection.querySelector('.condition-fields-container');
                const enableConditionCheckbox = passageSection.querySelector('[data-field="enableConditionVariable"]');
                if (conditionFieldsContainer && enableConditionCheckbox) {
                    conditionFieldsContainer.classList.toggle('hidden-field', !hotspot.enableConditionVariable);
                    enableConditionCheckbox.checked = hotspot.enableConditionVariable; // Sync checkbox state
                }

                const visitLimitInput = passageSection.querySelector('[data-field="visitLimit"]');
                const visitLimitTextContainer = passageSection.querySelector('.visit-limit-text-fields-container');
                if (visitLimitInput && visitLimitTextContainer) {
                    const hasValue = visitLimitInput.value.trim() !== '' && parseInt(visitLimitInput.value) > 0;
                    visitLimitTextContainer.classList.toggle('hidden-field', !hasValue);
                }
            }

            // Process Setter section if it exists
            if (setterSection) {
                const secondaryFieldsContainer = setterSection.querySelector('.secondary-variable-fields');
                const enableSecondaryCheckbox = setterSection.querySelector('[data-field="enableSecondaryVariable"]');
                if (secondaryFieldsContainer && enableSecondaryCheckbox) {
                    secondaryFieldsContainer.classList.toggle('hidden-field', !hotspot.enableSecondaryVariable);
                    enableSecondaryCheckbox.checked = hotspot.enableSecondaryVariable; // Sync checkbox state
                }

                const conditionFieldsContainer = setterSection.querySelector('.condition-fields-container');
                const enableConditionCheckbox = setterSection.querySelector('[data-field="enableConditionVariable"]');
                if (conditionFieldsContainer && enableConditionCheckbox) {
                    conditionFieldsContainer.classList.toggle('hidden-field', !hotspot.enableConditionVariable);
                    enableConditionCheckbox.checked = hotspot.enableConditionVariable; // Sync checkbox state
                }

                const visitLimitInput = setterSection.querySelector('[data-field="visitLimit"]');
                const visitLimitTextContainer = setterSection.querySelector('.visit-limit-text-fields-container');
                if (visitLimitInput && visitLimitTextContainer) {
                    const hasValue = visitLimitInput.value.trim() !== '' && parseInt(visitLimitInput.value) > 0;
                    visitLimitTextContainer.classList.toggle('hidden-field', !hasValue);
                }
            }
        }

        // Function to render hotspots in the image editor and configuration panel
        function renderHotspots() {
            hotspotsContainerEl.innerHTML = ''; // Clear current hotspot configurations
            // Remove visual hotspot elements from the image editor
            document.querySelectorAll('#imageEditor .hotspot-area').forEach(el => { if (el !== currentRect) el.remove(); });
            
            if (hotspots.length === 0) hotspotsContainerEl.innerHTML = '<p>No hi ha hotspots creats.</p>';

            if (imageDisplay.src && imageDisplay.naturalWidth && imageDisplay.naturalHeight) {
                const dispW = imageDisplay.offsetWidth, dispH = imageDisplay.offsetHeight,
                      natW = imageDisplay.naturalWidth, natH = imageDisplay.naturalHeight;
                const imgRectGlob = imageDisplay.getBoundingClientRect(), editorRectGlob = imageEditor.getBoundingClientRect(),
                      offsetXinEd = imgRectGlob.left - editorRectGlob.left, offsetYinEd = imgRectGlob.top - editorRectGlob.top,
                      scaleX = dispW / natW, scaleY = dispH / natH;
                
                hotspots.forEach(hotspot => {
                    const coordsArr = hotspot.coords.split(',').map(Number),
                          visRect = document.createElement('div');
                    visRect.classList.add('hotspot-area');
                    visRect.dataset.hotspotId = hotspot.id;
                    // Position and size visual hotspot based on scaled coordinates
                    visRect.style.left = `${(coordsArr[0] * scaleX) + offsetXinEd}px`;
                    visRect.style.top = `${(coordsArr[1] * scaleY) + offsetYinEd}px`;
                    visRect.style.width = `${(coordsArr[2] - coordsArr[0]) * scaleX}px`;
                    visRect.style.height = `${(coordsArr[3] - coordsArr[1]) * scaleY}px`;

                    // On editor, we don't have access to Harlowe variables, so we simplify the display logic
                    visRect.addEventListener('mouseenter', () => {
                        let info = '';
                        let currentFailInfoEnter = '';
                        let currentInfoText = '';

                        if (hotspot.type === 'passage') {
                            currentFailInfoEnter = hotspot.passageFailInfoEnter;
                            currentInfoText = hotspot.infoText;
                        } else if (hotspot.type === 'setter') {
                            currentFailInfoEnter = hotspot.setterFailInfoEnter;
                            currentInfoText = hotspot.infoTextSetter;
                        }

                        // Prioritize fail info in editor view if condition fields are filled
                        if ((hotspot.type === 'passage' && hotspot.passageConditionVariable && hotspot.passageConditionValue) ||
                            (hotspot.type === 'setter' && hotspot.setterConditionVariable && hotspot.setterConditionValue)) {
                            
                            if (currentFailInfoEnter) {
                                info = currentFailInfoEnter;
                            } else if (currentInfoText) {
                                info = currentInfoText;
                            }
                        } else {
                            // No condition, display regular info text
                            if (currentInfoText) {
                                info = currentInfoText;
                            }
                        }

                        // Prioritize visit limit text if limit is set and text is available
                        if (hotspot.visitLimit && hotspot.visitLimitTextEnter) {
                            info = hotspot.visitLimitTextEnter; // In editor, just show if present
                        }
                        
                        if (info) {
                            editorImageInfoDisplay.innerHTML = info.replace(/\n/g, '<br>');
                            editorImageInfoDisplay.style.display = 'block';
                        }
                    });
                    visRect.addEventListener('mouseleave', () => { editorImageInfoDisplay.innerHTML = ''; editorImageInfoDisplay.style.display = 'none'; });

                    // Add click listener to visual hotspot to scroll to its config
                    visRect.addEventListener('click', (e) => {
                        // Prevent this click from bubbling up to the document listener for Twine interaction
                        e.stopPropagation(); 
                        // Only scroll if no significant movement occurred during the mousedown-mouseup cycle
                        if (!hasMovedDuringInteraction) {
                            const id = parseInt(e.currentTarget.dataset.hotspotId);
                            const configElement = document.querySelector(`#hotspotsContainer .hotspot-item[data-hotspot-id="${id}"]`);
                            if (configElement) {
                                configElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }
                    });


                    const nameDisplay = document.createElement('div');
                    nameDisplay.classList.add('hotspot-name-display');
                    nameDisplay.textContent = hotspot.name || `Hotspot ${hotspot.id}`;
                    visRect.appendChild(nameDisplay);

                    const delBtn = document.createElement('div');
                    delBtn.classList.add('hotspot-delete-button-visual');
                    delBtn.textContent = 'X'; // Keep it as 'X'
                    delBtn.title = `Eliminar aquest hotspot (${hotspot.name || `Hotspot ${hotspot.id}`})`;
                    delBtn.addEventListener('click', (e) => { e.stopPropagation(); removeHotspot(hotspot.id); });
                    visRect.appendChild(delBtn);

                    // Add resize handle
                    const resizeHandle = document.createElement('div');
                    resizeHandle.classList.add('hotspot-resize-handle');
                    resizeHandle.title = "Redimensionar hotspot";
                    visRect.appendChild(resizeHandle);

                    imageEditor.appendChild(visRect);
                });
            }

            // Render configuration items for each hotspot
            hotspots.forEach(hotspot => {
                const item = document.createElement('div');
                item.classList.add('hotspot-item');
                item.dataset.hotspotId = hotspot.id;

                item.innerHTML = `
                    <div class="hotspot-section general-settings">
                        <label>Nom Hotspot:</label><input type="text" data-field="name" value="${hotspot.name || ''}" placeholder="Ej: Puerta">
                        <label>Acció:</label><select data-field="type"><option value="passage" ${hotspot.type==='passage'?'selected':''}>Anar Passatge</option><option value="setter" ${hotspot.type==='setter'?'selected':''}>Canviar Variable</option></select>
                    </div>
                    
                    <div class="hotspot-section setter-specific-fields ${hotspot.type==='setter'?'':'hidden-field'}">
                        <div class="two-column-layout">
                            <div class="column">
                                <label>Nom de la variable (ej: $nom_variable):</label><input type="text" data-field="variable" value="${hotspot.variable || ''}" placeholder="Ej: $punts">
                                <label>Valor de la variable (Número o text. Es pot sumar. Ej: +=100):</label><input type="text" data-field="valor" value="${hotspot.valor || ''}" placeholder="Ej: 1000 o &quot;text&quot;">
                                
                                <label>Text (mouse enter):</label><textarea data-field="infoTextSetter">${hotspot.infoTextSetter || ''}</textarea>
                                <label class="text-alternatiu-label">Text al fer clic (sota imatge - suporta Harlowe):</label><textarea data-field="infoTextSetter2">${hotspot.infoTextSetter2 || ''}</textarea>
                                <label>Etiqueta (apareix quan t'atures sobre):</label><input type="text" data-field="titleTextSetter" value="${hotspot.titleTextSetter || ''}">
                                <label>So (nom de l'àudio registrat a hal.tracks):</label><input type="text" data-field="soundSetter" value="${hotspot.soundSetter || ''}">

                                <div class="secondary-variable-toggle-container">
                                    <label class="darkblue-label">
                                        <input type="checkbox" data-field="enableSecondaryVariable" ${hotspot.enableSecondaryVariable ? 'checked' : ''}> Variable secundària
                                    </label>
                                </div>
                                <div class="secondary-variable-fields ${hotspot.enableSecondaryVariable ? '' : 'hidden-field'}">
                                    <label class="darkblue-label">Nom de la variable (secundària):</label><input type="text" data-field="variable2" value="${hotspot.variable2 || ''}" placeholder="Ej: $objecte_agafat">
                                    <label class="darkblue-label">Valor de la variable (secundària):</label><input type="text" data-field="valor2" value="${hotspot.valor2 || ''}" placeholder="Ej: &quot;espasa&quot;">
                                </div>
                            </div>
                            <div class="column condition-inputs-wrapper">
                                <!-- NEW: Checkbox for Condition Variable - Moved to the second column -->
                                <div class="condition-toggle-container">
                                    <label class="strong-red-label">
                                        <input type="checkbox" data-field="enableConditionVariable" ${hotspot.enableConditionVariable ? 'checked' : ''}> Activar Condició
                                    </label>
                                </div>
                                <div class="condition-fields-container ${hotspot.enableConditionVariable ? '' : 'hidden-field'}">
                                    <label class="condition-label">Variable (Condició):</label><input type="text" data-field="setterConditionVariable" value="${hotspot.setterConditionVariable || ''}" placeholder="Ej: $clau">
                                    <label class="condition-label">Valor (Condició):</label><input type="text" data-field="setterConditionValue" value="${hotspot.setterConditionValue || ''}" placeholder="Ej: true o 1">
                                    <label class="condition-label">Text de condició no assolida (mouse enter):</label><textarea data-field="setterFailInfoEnter">${hotspot.setterFailInfoEnter || ''}</textarea>
                                    <label class="condition-label">Text de condició no assolida (clic):</label><textarea data-field="setterFailInfo">${hotspot.setterFailInfo || ''}</textarea>
                                    <label class="condition-label">So (mentre no s'assoleix la condició:)</label><input type="text" data-field="setterSoundFail" value="${hotspot.setterSoundFail || ''}">
                                </div>
                                
                                <label class="limit-label">Límit de visites:</label><input type="number" data-field="visitLimit" value="${hotspot.visitLimit || ''}" placeholder="">
                                <div class="visit-limit-text-fields-container ${hotspot.visitLimit && parseInt(hotspot.visitLimit) > 0 ? '' : 'hidden-field'}">
                                    <label class="limit-label">Text de límit de visites (mouse enter):</label><textarea data-field="visitLimitTextEnter">${hotspot.visitLimitTextEnter || ''}</textarea>
                                    <label class="limit-label">Text de límit de visites (clic):</label><textarea data-field="visitLimitTextClic">${hotspot.visitLimitTextClic || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="hotspot-section passage-specific-fields ${hotspot.type==='passage'?'':'hidden-field'}">
                        <div class="two-column-layout">
                            <div class="column">
                                <label>Passatge destí:</label><input type="text" data-field="value" value="${hotspot.value || ''}" placeholder="Ej: Bosc">
                                
                                <label>Transició (al canviar de passatge):</label>
                                <select data-field="transition">
                                    <option value="">Cap</option>
                                    <option value="instant" ${hotspot.transition==='instant'?'selected':''}>Instantani</option>
                                    <option value="dissolve" ${hotspot.transition==='dissolve'?'selected':''}>Dissoldre</option>
                                    <option value="fade" ${hotspot.transition==='fade'?'selected':''}>Esvaïment</option>
                                    <option value="rumble" ${hotspot.transition==='rumble'?'selected':''}>Tremolor</option>
                                    <option value="shudder" ${hotspot.transition==='shudder'?'selected':''}>Estremiment</option>
                                    <option value="pulse" ${hotspot.transition==='pulse'?'selected':''}>Pulsació</option>
                                    <option value="zoom" ${hotspot.transition==='zoom'?'selected':''}>Zoom</option>
                                    <option value="flicker" ${hotspot.transition==='flicker'?'selected':''}>Parpelleig</option>
                                    <option value="slide-left" ${hotspot.transition==='slide-left'?'selected':''}>Lliscar Esquerra</option>
                                    <option value="slide-right" ${hotspot.transition==='slide-right'?'selected':''}>Lliscar Dreta</option>
                                    <option value="slide-up" ${hotspot.transition==='slide-up'?'selected':''}>Lliscar Amunt</option>
                                    <option value="slide-down" ${hotspot.transition==='slide-down'?'selected':''}>Lliscar Avall</option>
                                    <option value="fade-left" ${hotspot.transition==='fade-left'?'selected':''}>Esvaïment Esquerra</option>
                                    <option value="fade-right" ${hotspot.transition==='fade-right'?'selected':''}>Esvaïment Dreta</option>
                                    <option value="fade-up" ${hotspot.transition==='fade-up'?'selected':''}>Esvaïment Amunt</option>
                                    <option value="fade-down" ${hotspot.transition==='fade-down'?'selected':''}>Esvaïment Avall</option>
                                </select>
                                <label>Text (mouse enter):</label><textarea data-field="infoText">${hotspot.infoText || ''}</textarea>
                                <label class="text-alternatiu-label">Text al fer clic (sota imatge - suporta Harlowe):</label><textarea data-field="infoText2">${hotspot.infoText2 || ''}</textarea>
                                <label>Etiqueta (apareix quan t'atures sobre):</label><input type="text" data-field="titleText" value="${hotspot.titleText || ''}">
                                <label>So (nom de l'àudio registrat a hal.tracks):</label><input type="text" data-field="sound" value="${hotspot.sound || ''}">

                                <div class="secondary-variable-toggle-container">
                                    <label class="darkblue-label">
                                        <input type="checkbox" data-field="enableSecondaryVariable" ${hotspot.enableSecondaryVariable ? 'checked' : ''}> Variable secundària
                                    </label>
                                </div>
                                <div class="secondary-variable-fields ${hotspot.enableSecondaryVariable ? '' : 'hidden-field'}">
                                    <label class="darkblue-label">Nom de la variable (secundària):</label><input type="text" data-field="variable2" value="${hotspot.variable2 || ''}" placeholder="Ej: $objecte_agafat">
                                    <label class="darkblue-label">Valor de la variable (secundària):</label><input type="text" data-field="valor2" value="${hotspot.valor2 || ''}" placeholder="Ej: &quot;espasa&quot;">
                                </div>
                            </div>
                            <div class="column condition-inputs-wrapper">
                                <div class="condition-toggle-container">
                                    <label class="strong-red-label">
                                        <input type="checkbox" data-field="enableConditionVariable" ${hotspot.enableConditionVariable ? 'checked' : ''}> Activar Condició
                                    </label>
                                </div>
                                <div class="condition-fields-container ${hotspot.enableConditionVariable ? '' : 'hidden-field'}">
                                    <label class="condition-label">Variable (Condició):</label><input type="text" data-field="passageConditionVariable" value="${hotspot.passageConditionVariable || ''}" placeholder="Ej: $clau">
                                    <label class="condition-label">Valor (Condició):</label><input type="text" data-field="passageConditionValue" value="${hotspot.passageConditionValue || ''}" placeholder="Ej: true o 1">
                                    <label class="condition-label">Text de condició no assolida (mouse enter):</label><textarea data-field="passageFailInfoEnter">${hotspot.passageFailInfoEnter || ''}</textarea>
                                    <label class="condition-label">Text de condició no assolida (clic):</label><textarea data-field="passageFailInfo">${hotspot.passageFailInfo || ''}</textarea>
                                    <label class="condition-label">So (mentre no s'assoleix la condició:)</label><input type="text" data-field="passageSoundFail" value="${hotspot.passageSoundFail || ''}">
                                </div>

                                <label class="limit-label">Límit de visites:</label><input type="number" data-field="visitLimit" value="${hotspot.visitLimit || ''}" placeholder="">
                                <div class="visit-limit-text-fields-container ${hotspot.visitLimit && parseInt(hotspot.visitLimit) > 0 ? '' : 'hidden-field'}">
                                    <label class="limit-label">Text de límit de visites (mouse enter):</label><textarea data-field="visitLimitTextEnter">${hotspot.visitLimitTextEnter || ''}</textarea>
                                    <label class="limit-label">Text de límit de visites (clic):</label><textarea data-field="visitLimitTextClic">${hotspot.visitLimitTextClic || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    </div>

                    <button class="delete-config-button">Eliminar ${hotspot.name || `Hotspot ${hotspot.id}`}</button>`;
                hotspotsContainerEl.appendChild(item);

                const pFields = item.querySelector('.passage-specific-fields');
                const sFields = item.querySelector('.setter-specific-fields');
                
                // Function to toggle visibility of main fields based on hotspot type
                const toggle = type => {
                    pFields.classList.toggle('hidden-field', type !== 'passage');
                    sFields.classList.toggle('hidden-field', type !== 'setter');
                    // After toggling the main sections, update the inner field visibility for the active section
                    updateInnerFieldVisibility(hotspot, item);
                };

                toggle(hotspot.type); // Initial toggle based on current type

                const deleteConfigButton = item.querySelector('.delete-config-button');

                // Event listeners for updating hotspot properties
                item.querySelector('input[data-field="name"]').addEventListener('input', e => {
                    hotspot.name = e.target.value;
                    generateTwineCode();
                    hideCopyFeedback();
                    const hotspotElement = document.querySelector(`.hotspot-area[data-hotspot-id="${hotspot.id}"] .hotspot-name-display`);
                    if (hotspotElement) {
                        hotspotElement.textContent = e.target.value;
                    }
                    // Update the delete button text in the config panel as well
                    deleteConfigButton.textContent = `Eliminar ${e.target.value || `Hotspot ${hotspot.id}`}`;
                });
                item.querySelector('select[data-field="type"]').addEventListener('change', e => {
                    hotspot.type = e.target.value;
                    toggle(hotspot.type); // This call will now also update inner field visibility
                    generateTwineCode();
                    hideCopyFeedback();
                });
                
                // Update event listeners for 'value' (passage) and 'variable', 'valor' (setter)
                ['value', 'infoText2', 'titleText','sound','infoText'].forEach(f => {
                    const element = item.querySelector(`.passage-specific-fields [data-field="${f}"]`);
                    if (element) {
                        element.addEventListener('input', e => {
                            hotspot[f] = e.target.value;
                            generateTwineCode();
                            hideCopyFeedback();
                        });
                    }
                });

                // Specific listener for 'transition' select element
                const passageTransitionSelect = item.querySelector('.passage-specific-fields [data-field="transition"]');
                if (passageTransitionSelect) {
                    passageTransitionSelect.addEventListener('change', e => {
                        hotspot.transition = e.target.value;
                        generateTwineCode();
                        hideCopyFeedback();
                    });
                }

                ['variable', 'valor', 'titleTextSetter','soundSetter','infoTextSetter','infoTextSetter2'].forEach(f => {
                    const element = item.querySelector(`.setter-specific-fields [data-field="${f}"]`);
                    if (element) {
                        element.addEventListener('input', e => {
                            hotspot[f] = e.target.value;
                            generateTwineCode();
                            hideCopyFeedback();
                        });
                    }
                });

                // Event listeners for secondary variable fields (common to both types)
                // Attach to the checkbox within the passage section
                const pEnableSecondaryVariableCheckbox = pFields.querySelector('[data-field="enableSecondaryVariable"]');
                if (pEnableSecondaryVariableCheckbox) {
                    pEnableSecondaryVariableCheckbox.addEventListener('change', (e) => {
                        hotspot.enableSecondaryVariable = e.target.checked;
                        updateInnerFieldVisibility(hotspot, item);
                        generateTwineCode();
                        hideCopyFeedback();
                    });
                }
                // Attach to the checkbox within the setter section
                const sEnableSecondaryVariableCheckbox = sFields.querySelector('[data-field="enableSecondaryVariable"]');
                if (sEnableSecondaryVariableCheckbox) {
                    sEnableSecondaryVariableCheckbox.addEventListener('change', (e) => {
                        hotspot.enableSecondaryVariable = e.target.checked;
                        updateInnerFieldVisibility(hotspot, item);
                        generateTwineCode();
                        hideCopyFeedback();
                    });
                }

                // Also attach listeners for the secondary fields themselves (variable2, valor2)
                // These are common, so we need to find them in both sections
                const pVariable2Input = pFields.querySelector('[data-field="variable2"]');
                const pValor2Input = pFields.querySelector('[data-field="valor2"]');
                const sVariable2Input = sFields.querySelector('[data-field="variable2"]');
                const sValor2Input = sFields.querySelector('[data-field="valor2"]');

                if (pVariable2Input) pVariable2Input.addEventListener('input', e => { hotspot.variable2 = e.target.value; generateTwineCode(); hideCopyFeedback(); });
                if (pValor2Input) pValor2Input.addEventListener('input', e => { hotspot.valor2 = e.target.value; generateTwineCode(); hideCopyFeedback(); });
                if (sVariable2Input) sVariable2Input.addEventListener('input', e => { hotspot.variable2 = e.target.value; generateTwineCode(); hideCopyFeedback(); });
                if (sValor2Input) sValor2Input.addEventListener('input', e => { hotspot.valor2 = e.target.value; generateTwineCode(); hideCopyFeedback(); });


                // Passage-specific condition fields listeners
                ['passageConditionVariable', 'passageConditionValue', 'passageFailInfo', 'passageFailInfoEnter', 'passageSoundFail'].forEach(f => {
                    const element = item.querySelector(`.passage-specific-fields [data-field="${f}"]`);
                    if (element) {
                        element.addEventListener('input', e => {
                            hotspot[f] = e.target.value;
                            generateTwineCode();
                            hideCopyFeedback();
                        });
                    }
                });

                // Setter-specific condition fields listeners
                ['setterConditionVariable', 'setterConditionValue', 'setterFailInfo', 'setterFailInfoEnter', 'setterSoundFail'].forEach(f => {
                    const element = item.querySelector(`.setter-specific-fields [data-field="${f}"]`);
                    if (element) {
                        element.addEventListener('input', e => {
                            hotspot[f] = e.target.value;
                            generateTwineCode();
                            hideCopyFeedback();
                        });
                    }
                });
                
                // Visit Limit fields listeners (common for both types)
                // Attach to the input within the passage section
                const pVisitLimitInput = pFields.querySelector('[data-field="visitLimit"]');
                if (pVisitLimitInput) {
                    pVisitLimitInput.addEventListener('input', (e) => {
                        hotspot.visitLimit = e.target.value; // Update hotspot object
                        updateInnerFieldVisibility(hotspot, item); // Call to update visibility
                        generateTwineCode();
                        hideCopyFeedback();
                    });
                }
                // Attach to the input within the setter section
                const sVisitLimitInput = sFields.querySelector('[data-field="visitLimit"]');
                if (sVisitLimitInput) {
                    sVisitLimitInput.addEventListener('input', (e) => {
                        hotspot.visitLimit = e.target.value; // Update hotspot object
                        updateInnerFieldVisibility(hotspot, item); // Call to update visibility
                        generateTwineCode();
                        hideCopyFeedback();
                    });
                }
                // Also attach listeners for the visit limit text fields
                const pVisitLimitTextEnter = pFields.querySelector('[data-field="visitLimitTextEnter"]');
                const pVisitLimitTextClic = pFields.querySelector('[data-field="visitLimitTextClic"]');
                const sVisitLimitTextEnter = sFields.querySelector('[data-field="visitLimitTextEnter"]');
                const sVisitLimitTextClic = sFields.querySelector('[data-field="visitLimitTextClic"]');

                if (pVisitLimitTextEnter) pVisitLimitTextEnter.addEventListener('input', e => { hotspot.visitLimitTextEnter = e.target.value; generateTwineCode(); hideCopyFeedback(); });
                if (pVisitLimitTextClic) pVisitLimitTextClic.addEventListener('input', e => { hotspot.visitLimitTextClic = e.target.value; generateTwineCode(); hideCopyFeedback(); });
                if (sVisitLimitTextEnter) sVisitLimitTextEnter.addEventListener('input', e => { hotspot.visitLimitTextEnter = e.target.value; generateTwineCode(); hideCopyFeedback(); });
                if (sVisitLimitTextClic) sVisitLimitTextClic.addEventListener('input', e => { hotspot.visitLimitTextClic = e.target.value; generateTwineCode(); hideCopyFeedback(); });


                // Event listener for the NEW "enableConditionVariable" checkbox
                // Attach to the checkbox within the passage section
                const pEnableConditionVariableCheckbox = pFields.querySelector('[data-field="enableConditionVariable"]');
                if (pEnableConditionVariableCheckbox) {
                    pEnableConditionVariableCheckbox.addEventListener('change', (e) => {
                        hotspot.enableConditionVariable = e.target.checked;
                        updateInnerFieldVisibility(hotspot, item);
                        generateTwineCode();
                        hideCopyFeedback();
                    });
                }
                // Attach to the checkbox within the setter section
                const sEnableConditionVariableCheckbox = sFields.querySelector('[data-field="enableConditionVariable"]');
                if (sEnableConditionVariableCheckbox) {
                    sEnableConditionVariableCheckbox.addEventListener('change', (e) => {
                        hotspot.enableConditionVariable = e.target.checked;
                        updateInnerFieldVisibility(hotspot, item);
                        generateTwineCode();
                        hideCopyFeedback();
                    });
                }

                item.querySelector('.delete-config-button').addEventListener('click', () => { removeHotspot(hotspot.id); hideCopyFeedback(); });
            });
        }

        // Function to remove a hotspot
        function removeHotspot(id) {
            hotspots = hotspots.filter(h => h.id !== id);
            renderHotspots();
            generateTwineCode();
        }

        // Helper function to ensure variable names start with '$'
        function formatVariable(varName) {
            if (varName && typeof varName === 'string' && !varName.startsWith('$')) {
                return '$' + varName;
            }
            return varName;
        }

        // Function to generate Twine (Harlowe) code
        function generateTwineCode() {
            if (!imageDisplay.src || !imageDisplay.naturalWidth || !imageUpload.files || imageUpload.files.length === 0) {
                outputCode.value = "<p>Carga una imagen para generar el código.</p>";
                return;
            }
            const originalFileName = imageUpload.files[0].name;
            let twineCode = `<div class="twine-image-wrapper" style="min-width:${imageDisplay.naturalWidth}px;">\n`;
            twineCode += `    <img src="imatges/${originalFileName.replace(/"/g, '&quot;')}" usemap="#hotspotmap" alt="Imatge amb hotspots">\n`;
            twineCode += '    <map name="hotspotmap">\n';
            hotspots.forEach(hotspot => {
                const coords = hotspot.coords;

                const altText = (hotspot.name || `Hotspot ${hotspot.id}`).replace(/"/g, '&quot;');
                
                // Add comment for each hotspot in HTML comment format
                twineCode += `    <!-- ${hotspot.name || `Hotspot ${hotspot.id}`} -->\n`;
                let areaTag = `        <area shape="rect"\n`;
                areaTag += `            coords="${coords}"\n`;
                areaTag += `            alt="${altText}"\n`;
                areaTag += `            class="hotspot-item"\n`;
                
                // Condition attributes are now type-specific
                if (hotspot.type === 'passage') {
                    // Only include condition attributes if enabled or has values
                    if (hotspot.enableConditionVariable || (hotspot.passageConditionVariable && hotspot.passageConditionValue)) {
                        if (hotspot.passageConditionVariable && hotspot.passageConditionValue) {
                            areaTag += `            data-condition-var="${formatVariable(hotspot.passageConditionVariable).replace(/"/g, '&quot;')}"\n`;
                            areaTag += `            data-condition-val="${hotspot.passageConditionValue.replace(/"/g, '&quot;')}"\n`;
                            if (hotspot.passageFailInfo) areaTag += `            text_fail_clic="${hotspot.passageFailInfo.replace(/"/g, '&quot;')}"\n`;
                            if (hotspot.passageFailInfoEnter) areaTag += `            text_fail_enter="${hotspot.passageFailInfoEnter.replace(/"/g, '&quot;')}"\n`;
                            if (hotspot.passageSoundFail) areaTag += `            data-sound-fail="${hotspot.passageSoundFail.replace(/"/g, '&quot;')}"\n`;
                        }
                    }
                    // Only include data-sound if it has a value
                    if (hotspot.sound) areaTag += `            data-sound="${hotspot.sound.replace(/"/g, '&quot;')}"\n`;
                    if (hotspot.value) areaTag += `            data-passage="${hotspot.value.replace(/"/g, '&quot;')}"\n`;
                    if (hotspot.titleText) areaTag += `            title="${hotspot.titleText.replace(/"/g, '&quot;')}"\n`;
                    if (hotspot.infoText) areaTag += `            data_info="${hotspot.infoText.replace(/"/g, '&quot;')}"\n`;
                    if (hotspot.infoText2) areaTag += `            data_info_2="${hotspot.infoText2.replace(/"/g, '&quot;')}"\n`;
                    if (hotspot.transition) areaTag += `            data-transition-depart="${hotspot.transition.replace(/"/g, '&quot;')}"\n`; 

                    // Secondary Setter attributes for passage type (only if enabled or has values)
                    if (hotspot.enableSecondaryVariable || (hotspot.variable2 && hotspot.valor2)) {
                        if (hotspot.variable2) areaTag += `            data-variable-2="${formatVariable(hotspot.variable2).replace(/"/g, '&quot;')}"\n`;
                        if (hotspot.valor2) areaTag += `            data-valor-2="${hotspot.valor2.replace(/"/g, '&quot;')}"\n`;
                    }

                } else if (hotspot.type === 'setter') {
                    // Only include condition attributes if enabled or has values
                    if (hotspot.enableConditionVariable || (hotspot.setterConditionVariable && hotspot.setterConditionValue)) {
                        if (hotspot.setterConditionVariable && hotspot.setterConditionValue) {
                            areaTag += `            data-condition-var="${formatVariable(hotspot.setterConditionVariable).replace(/"/g, '&quot;')}"\n`;
                            areaTag += `            data-condition-val="${hotspot.setterConditionValue.replace(/"/g, '&quot;')}"\n`;
                            if (hotspot.setterFailInfo) areaTag += `            text_fail_clic="${hotspot.setterFailInfo.replace(/"/g, '&quot;')}"\n`;
                            if (hotspot.setterFailInfoEnter) areaTag += `            text_fail_enter="${hotspot.setterFailInfoEnter.replace(/"/g, '&quot;')}"\n`;
                            if (hotspot.setterSoundFail) areaTag += `            data-sound-fail="${hotspot.setterSoundFail.replace(/"/g, '&quot;')}"\n`;
                        }
                    }
                    // Only include data-sound if it has a value
                    if (hotspot.soundSetter) areaTag += `            data-sound="${hotspot.soundSetter.replace(/"/g, '&quot;')}"\n`;
                    let setMacroContent = '';
                    const valorRaw = hotspot.valor;
                    const valorTrimmed = valorRaw.trim();
                    const arithmeticOperators = ['+', '-', '*', '/', '%'];
                    const startsWithArithmeticOperator = arithmeticOperators.some(op => valorTrimmed.startsWith(op));
                    const hasOtherOperator = ['>', '<', 'is', '=', 'to'].some(op => valorTrimmed.startsWith(op));

                    const formattedVariableName = formatVariable(hotspot.variable); // Format variable name here

                    if (formattedVariableName) {
                        let formattedValorForMacro = valorTrimmed;
                        
                        if (startsWithArithmeticOperator) {
                            setMacroContent = `${formattedVariableName} ${valorTrimmed}`;
                        } else if (!isNaN(valorTrimmed) && valorTrimmed !== '') {
                            setMacroContent = `${formattedVariableName} = ${formattedValorForMacro}`;
                        } else {
                            if (!hasOtherOperator) {
                                formattedValorForMacro = `"${valorTrimmed.replace(/"/g, '\\"')}"`;
                            }
                            setMacroContent = `${formattedVariableName} = ${formattedValorForMacro}`;
                        }
                    }
                    
                    if (setMacroContent) areaTag += `            data-setter="${setMacroContent.replace(/"/g, '&quot;')}"\n`;
                    if (hotspot.titleTextSetter) areaTag += `            title="${hotspot.titleTextSetter.replace(/"/g, '&quot;')}"\n`;
                    if (hotspot.infoTextSetter) areaTag += `            data_info="${hotspot.infoTextSetter.replace(/"/g, '&quot;')}"\n`;
                    if (hotspot.infoTextSetter2) areaTag += `            data_info_2="${hotspot.infoTextSetter2.replace(/"/g, '&quot;')}"\n`;
                    
                    if (formattedVariableName) areaTag += `            data_variable="${formattedVariableName}"\n`;
                    if (hotspot.valor) areaTag += `            data_valor="${hotspot.valor}"\n`;

                    // Secondary Setter attributes (only if enabled or has values)
                    if (hotspot.enableSecondaryVariable || (hotspot.variable2 && hotspot.valor2)) {
                        if (hotspot.variable2) areaTag += `            data-variable-2="${formatVariable(hotspot.variable2).replace(/"/g, '&quot;')}"\n`;
                        if (hotspot.valor2) areaTag += `            data-valor-2="${hotspot.valor2.replace(/"/g, '&quot;')}"\n`;
                    }
                }

                // Visit Limit attributes (common for both types)
                if (hotspot.visitLimit) areaTag += `            data-visit-limit="${hotspot.visitLimit.replace(/"/g, '&quot;')}"\n`;
                if (hotspot.visitLimitTextEnter) areaTag += `            data-visit-limit-enter="${hotspot.visitLimitTextEnter.replace(/"/g, '&quot;')}"\n`;
                if (hotspot.visitLimitTextClic) areaTag += `            data-visit-limit-clic="${hotspot.visitLimitTextClic.replace(/"/g, '&quot;')}"\n`;

                areaTag += `        >\n`; // Close the area tag
                twineCode += areaTag;
                twineCode += `\n`; // Add an extra newline for separation
            });
            twineCode += '    </map>\n';
            twineCode += `    <div id="twineImageInfoDisplay" style="display: none;">(live: 0.1s)[(print: $tempInfoDisplay)]</div>\n`;
            twineCode += '</div>\n\n';

            // Generate Harlowe links for passages
            twineCode += '(live: 0.1s)[\n';
            twineCode += '    <span id="Ocult" style="display:none;">\n';
            hotspots.forEach(hotspot => {
                if (hotspot.type === 'passage' && hotspot.value) {
                    const passageNameForLink = hotspot.value.replace(/"/g, '\\"');
                    let harloweLinkContent = `(goto: "${passageNameForLink}")`;
                    
                    if (hotspot.transition && hotspot.transition !== 'Cap' && hotspot.transition !== 'instant') {
                        harloweLinkContent = `(transition-depart: "${hotspot.transition.replace(/"/g, '\\"')}")` + harloweLinkContent;
                    }

                    let harloweLink = '';
                    // Only generate conditional link if enabled or has values
                    if (hotspot.enableConditionVariable || (hotspot.passageConditionVariable && hotspot.passageConditionValue)) {
                        if (hotspot.passageConditionVariable && hotspot.passageConditionValue) { // Use passage-specific condition
                            let conditionValueFormatted = hotspot.passageConditionValue;
                            const startsWithOperator = ['>', '<', 'is', '=', 'not', 'contains'].some(op => conditionValueFormatted.trim().startsWith(op));
                            if (!isNaN(conditionValueFormatted) && !startsWithOperator && conditionValueFormatted.trim() !== '') {
                                conditionValueFormatted = `is ${conditionValueFormatted}`;
                            } else if (isNaN(conditionValueFormatted) && !startsWithOperator && conditionValueFormatted.trim() !== '') {
                                conditionValueFormatted = `is "${conditionValueFormatted.replace(/"/g, '\\"')}"`;
                            }
                            harloweLink = `    (if: ${formatVariable(hotspot.passageConditionVariable)} ${conditionValueFormatted})[(link: "${passageNameForLink}")[${harloweLinkContent}]]`;
                        } else {
                            harloweLink = `    (link: "${passageNameForLink}")[${harloweLinkContent}]`;
                        }
                    } else {
                        harloweLink = `    (link: "${passageNameForLink}")[${harloweLinkContent}]`;
                    }
                    twineCode += `${harloweLink}\n`;
                }
            });
            twineCode += '    </span>\n';
            twineCode += ']\n';

            outputCode.value = twineCode;
        }

        // Event listener for copy code button
        copyCodeButton.addEventListener('click', () => {
            outputCode.select(); // Select the text in the textarea
            document.execCommand('copy'); // Copy to clipboard
            copyFeedback.style.display = 'inline-block'; // Show feedback message
            setTimeout(() => {
                copyFeedback.style.display = 'none'; // Hide feedback message after 2 seconds
            }, 2000);
        });

        // Event listener for load code button
        loadCodeButton.addEventListener('click', () => {
            hideCopyFeedback(); // Hide feedback on load
            const codeToParse = outputCode.value;
            if (codeToParse.trim() === "") {
                alert("El campo de código está vacío. Pega el código HTML/Harlowe para cargar.");
                return;
            }
            parseTwineCode(codeToParse);
        });

        // Function to parse existing Twine code and populate the editor
        function parseTwineCode(code) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(code, 'text/html'); // Parse into a full document

            const imgElement = doc.querySelector('.twine-image-wrapper img[usemap]'); // Be more specific
            if (!imgElement) {
                alert("No se ha encontrado ninguna etiqueta <img> con usemap dentro de .twine-image-wrapper.");
                return;
            }

            const mapName = imgElement.getAttribute('usemap').substring(1); // Get map name without '#'
            const mapElement = doc.querySelector(`map[name="${mapName}"]`);

            if (!mapElement) {
                alert(`No se ha encontrado la etiqueta <map name="${mapName}"> asociada a la imagen.`);
                return;
            }

            // Reset hotspots and counter
            hotspots = [];
            let maxHotspotId = 0;
            const areaElements = mapElement.querySelectorAll('area'); // Query areas directly from the map
            areaElements.forEach(area => {
                const coords = area.getAttribute('coords');
                const altText = area.getAttribute('alt');
                const dataPassage = area.getAttribute('data-passage');
                const dataSetter = area.getAttribute('data-setter'); // This will be the combined string
                const title = area.getAttribute('title');
                const dataSound = area.getAttribute('data-sound');
                const dataInfo = area.getAttribute('data_info');
                const dataInfo2 = area.getAttribute('data_info_2');
                
                // Common condition attributes from HTML
                const dataConditionVar = area.getAttribute('data-condition-var');
                const dataConditionVal = area.getAttribute('data-condition-val');
                const dataFailInfoClic = area.getAttribute('text_fail_clic');
                const dataFailInfoEnter = area.getAttribute('text_fail_enter');
                const dataSoundFail = area.getAttribute('data-sound-fail');
                
                const dataTransition = area.getAttribute('data-transition-depart'); 

                // Retrieve visit limit attributes
                const visitLimit = area.getAttribute('data-visit-limit');
                const visitLimitTextEnter = area.getAttribute('data-visit-limit-enter');
                const visitLimitTextClic = area.getAttribute('data-visit-limit-clic');

                // Declare dataVariable, dataValor, dataVariable2, dataValor2 here to ensure they are always in scope
                const dataVariable = area.getAttribute('data_variable');
                const dataValor = area.getAttribute('data_valor');
                const dataVariable2 = area.getAttribute('data-variable-2');
                const dataValor2 = area.getAttribute('data-valor-2');

                hotspotIdCounter++;
                maxHotspotId = Math.max(maxHotspotId, hotspotIdCounter);

                let newHotspot = {
                    id: hotspotIdCounter,
                    coords: coords,
                    name: altText || `Hotspot ${hotspotIdCounter}`,
                    type: 'passage', // Default type
                    value: '',
                    titleText: '',
                    sound: '',
                    infoText: '',
                    infoText2: '',
                    transition: '',
                    variable: '', // Will be assigned below
                    valor: '',    // Will be assigned below
                    titleTextSetter: '',
                    soundSetter: '',
                    infoTextSetter: '',
                    infoTextSetter2: '',
                    
                    // Passage specific condition fields
                    passageConditionVariable: '',
                    passageConditionValue: '',
                    passageFailInfo: '',
                    passageFailInfoEnter: '',
                    passageSoundFail: '',

                    // Setter specific condition fields
                    setterConditionVariable: '',
                    setterConditionValue: '',
                    setterFailInfo: '',
                    setterFailInfoEnter: '',
                    setterSoundFail: '',

                    // Visit Limit fields (common for both types)
                    visitLimit: visitLimit || '',
                    visitLimitTextEnter: visitLimitTextEnter || '',
                    visitLimitTextClic: visitLimitTextClic || '',

                    // Secondary Setter fields
                    variable2: dataVariable2 || '',
                    valor2: dataValor2 || '',
                    enableSecondaryVariable: (dataVariable2 || dataValor2) ? true : false, // Set based on loaded data
                    enableConditionVariable: (dataConditionVar || dataConditionVal || dataFailInfoClic || dataFailInfoEnter || dataSoundFail) ? true : false // Set based on loaded condition data
                };
                
                if (dataPassage) {
                    newHotspot.type = 'passage';
                    newHotspot.value = dataPassage;
                    newHotspot.titleText = title || '';
                    newHotspot.sound = dataSound || ''; // Assign dataSound for passage
                    newHotspot.infoText = dataInfo || '';
                    newHotspot.infoText2 = dataInfo2 || '';
                    newHotspot.transition = dataTransition || '';
                    // Assign passage-specific condition fields
                    newHotspot.passageConditionVariable = dataConditionVar || '';
                    newHotspot.passageConditionValue = dataConditionVal || '';
                    newHotspot.passageFailInfo = dataFailInfoClic || '';
                    newHotspot.passageFailInfoEnter = dataFailInfoEnter || '';
                    newHotspot.passageSoundFail = dataSoundFail || '';
                    // Assign secondary setter fields for passage type
                    newHotspot.variable2 = dataVariable2 || '';
                    newHotspot.valor2 = dataValor2 || '';
                } else if (dataSetter) {
                    newHotspot.type = 'setter';
                    newHotspot.variable = dataVariable || ''; // Now dataVariable is defined
                    newHotspot.valor = dataValor || '';       // Now dataValor is defined
                    newHotspot.titleTextSetter = title || '';
                    newHotspot.soundSetter = dataSound || ''; // Assign dataSound for setter
                    newHotspot.infoTextSetter = dataInfo || '';
                    newHotspot.infoTextSetter2 = dataInfo2 || '';
                    // Assign setter-specific condition fields
                    newHotspot.setterConditionVariable = dataConditionVar || '';
                    newHotspot.setterConditionValue = dataConditionVal || '';
                    newHotspot.setterFailInfo = dataFailInfoClic || '';
                    newHotspot.setterFailInfoEnter = dataFailInfoEnter || '';
                    newHotspot.setterSoundFail = dataSoundFail || '';
                }
                hotspots.push(newHotspot);
            });
            hotspotIdCounter = maxHotspotId;

            renderHotspots();
            generateTwineCode();
        }

        // Initial rendering and code generation on page load
        renderHotspots();
        generateTwineCode();
        // Add event listener for window resize to re-render hotspots
        window.addEventListener('resize', renderHotspots);
        
        // --- JAVASCRIPT PER A LA INTERACCIÓ DEL HOTSPOT ---
        // Function to check condition
        function checkCondition(areaElement) {
            const hasCondition = areaElement.hasAttribute('data-condition-var') && areaElement.hasAttribute('data-condition-val');
            if (!hasCondition) return true; // No condition, so it's always met

            const conditionVar = areaElement.getAttribute('data-condition-var');
            const conditionVal = areaElement.getAttribute('data-condition-val');
            
            const actualVariableValue = window.Harlowe.get(conditionVar);
            let expectedConditionValue;

            if (conditionVal.toLowerCase() === 'true') {
                expectedConditionValue = true;
            } else if (conditionVal.toLowerCase() === 'false') {
                expectedConditionValue = false;
            }
            else if (!isNaN(conditionVal) && conditionVal.trim() !== '') {
                expectedConditionValue = Number(conditionVal);
            } else {
                if (conditionVal.startsWith('"') && conditionVal.endsWith('"') && conditionVal.length > 1) {
                    expectedConditionValue = conditionVal.substring(1, conditionVal.length - 1);
                } else {
                    expectedConditionValue = conditionVal;
                }
            }
            
            let compareVariableValue = actualVariableValue;
            let compareExpectedValue = expectedConditionValue;

            if (typeof actualVariableValue === 'number' && typeof expectedConditionValue === 'string' && !isNaN(expectedConditionValue)) {
                compareExpectedValue = Number(expectedConditionValue);
            } else if (typeof actualVariableValue === 'string' && typeof expectedConditionValue === 'number' && !isNaN(actualVariableValue)) {
                compareVariableValue = Number(actualVariableValue);
            }

            return (compareVariableValue === expectedConditionValue);
        }

        // Mouse over (mouse enter) event listener for Twine runtime
        document.addEventListener('mouseover', (e) => {
            if (e.target.tagName === 'AREA' && e.target.classList.contains('hotspot-item')) {
                const twineInfoDisplay = document.getElementById('twineImageInfoDisplay');
                let infoTextToDisplay = '';
                let failInfoEnterToDisplay = '';
                let visitLimitTextEnterToDisplay = '';

                // Determine which info/fail texts to use based on hotspot type
                if (e.target.hasAttribute('data-passage')) {
                    infoTextToDisplay = e.target.getAttribute('data_info');
                    failInfoEnterToDisplay = e.target.getAttribute('text_fail_enter');
                } else if (e.target.hasAttribute('data-setter')) {
                    infoTextToDisplay = e.target.getAttribute('data_info'); // data_info is used for mouse enter text for setters too
                    failInfoEnterToDisplay = e.target.getAttribute('text_fail_enter');
                }

                // Get visit limit text for mouse enter
                visitLimitTextEnterToDisplay = e.target.getAttribute('data-visit-limit-enter');

                if (twineInfoDisplay) {
                    let textToShow = '';

                    // Check for general condition first
                    const hasGeneralCondition = e.target.hasAttribute('data-condition-var') && e.target.hasAttribute('data-condition-val');
                    const isGeneralConditionMet = hasGeneralCondition ? checkCondition(e.target) : true;

                    // Check for visit limit
                    const hasVisitLimit = e.target.hasAttribute('data-visit-limit');
                    let isVisitLimitReached = false;
                    if (hasVisitLimit) {
                        const hotspotId = e.target.id || e.target.dataset.hotspotId; // Use ID if available, otherwise dataset ID
                        const visitLimit = parseInt(e.target.getAttribute('data-visit-limit'));
                        const currentVisits = window.Harlowe.get(`$visits_hotspot_${hotspotId}`) || 0; // Assume a Twine variable for visits
                        isVisitLimitReached = currentVisits >= visitLimit;
                    }

                    if (hasGeneralCondition && !isGeneralConditionMet) {
                        // General condition not met, prioritize fail info
                        textToShow = failInfoEnterToDisplay || '';
                    } else if (hasVisitLimit && isVisitLimitReached) {
                        // Visit limit reached, prioritize visit limit text
                        textToShow = visitLimitTextEnterToDisplay || '';
                    } else {
                        // All conditions met or no conditions, show regular info
                        textToShow = infoTextToDisplay || '';
                    }
                    
                    if (textToShow) {
                        window.Harlowe.set('$tempInfoDisplay', textToShow);
                        twineInfoDisplay.style.display = 'block';
                    } else {
                        twineInfoDisplay.style.display = 'none';
                        window.Harlowe.set('$tempInfoDisplay', '');
                    }
                }
            }
        });

        // Mouse out event listener for Twine runtime
        document.addEventListener('mouseout', (e) => {
            if (e.target.tagName === 'AREA' && e.target.classList.contains('hotspot-item')) {
                const twineInfoDisplay = document.getElementById('twineImageInfoDisplay');
                if (twineInfoDisplay) {
                    twineInfoDisplay.style.display = 'none';
                    window.Harlowe.set('$tempInfoDisplay', '');
                }
            }
        });


        document.addEventListener('click', (e) => {
            if (e.target.tagName === 'AREA' && e.target.classList.contains('hotspot-item')) {
                const hotspotName = e.target.getAttribute('alt'); // Obtenir el text alt (nom del hotspot)
                const dataSound = e.target.getAttribute('data-sound');
                const dataSoundFail = e.target.getAttribute('data-sound-fail');
                const twineInfoDisplay = document.getElementById('twineImageInfoDisplay');

                let infoText2ToDisplay = '';
                let failInfoClicToDisplay = '';
                let visitLimitTextClicToDisplay = '';

                // Determine which info/fail texts to use based on hotspot type
                if (e.target.hasAttribute('data-passage')) {
                    infoText2ToDisplay = e.target.getAttribute('data_info_2');
                    failInfoClicToDisplay = e.target.getAttribute('text_fail_clic');
                } else if (e.target.hasAttribute('data-setter')) {
                    infoText2ToDisplay = e.target.getAttribute('data_info_2');
                    failInfoClicToDisplay = e.target.getAttribute('text_fail_clic');
                }

                // Get visit limit text for click
                visitLimitTextClicToDisplay = e.target.getAttribute('data-visit-limit-clic');

                // Check for general condition
                const hasGeneralCondition = e.target.hasAttribute('data-condition-var') && e.target.hasAttribute('data-condition-val');
                const isGeneralConditionMet = hasGeneralCondition ? checkCondition(e.target) : true;

                // Check for visit limit
                const hasVisitLimit = e.target.hasAttribute('data-visit-limit');
                let isVisitLimitReached = false;
                if (hasVisitLimit) {
                    const hotspotId = e.target.id || e.target.dataset.hotspotId; // Use ID if available, otherwise dataset ID
                    const visitLimit = parseInt(e.target.getAttribute('data-visit-limit'));
                    const currentVisits = window.Harlowe.get(`$visits_hotspot_${hotspotId}`) || 0; // Assume a Twine variable for visits
                    isVisitLimitReached = currentVisits >= visitLimit;
                }

                let preventAction = false;
                let textToShow = '';
                let soundToPlay = dataSound; // Default sound

                if (hasGeneralCondition && !isGeneralConditionMet) {
                    // General condition not met
                    textToShow = failInfoClicToDisplay || '';
                    soundToPlay = dataSoundFail || dataSound; // Prioritize fail sound
                    preventAction = true;
                } else if (hasVisitLimit && isVisitLimitReached) {
                    // Visit limit reached
                    textToShow = visitLimitTextClicToDisplay || '';
                    soundToPlay = dataSoundFail || dataSound; // Use fail sound if available, otherwise normal
                    preventAction = true;
                } else {
                    // All conditions met or no conditions, proceed with normal action
                    textToShow = infoText2ToDisplay || '';
                    soundToPlay = dataSound;
                }

                if (twineInfoDisplay) {
                    if (textToShow) {
                        window.Harlowe.set('$tempInfoDisplay', textToShow);
                        twineInfoDisplay.style.display = 'block';
                    } else {
                        twineInfoDisplay.style.display = 'none';
                        window.Harlowe.set('$tempInfoDisplay', '');
                    }
                }

                // Play sound
                if (soundToPlay && window.hal && window.hal.tracks && window.hal.tracks[soundToPlay]) {
                    window.hal.tracks[soundToPlay].play();
                }

                if (preventAction) {
                    console.log(`Acción prevenida para el hotspot: ${hotspotName} (condición no cumplida o límite de visitas alcanzado).`);
                    return; // Stop execution if action is prevented
                }

                // Proceed with action only if all conditions are met
                if (e.target.hasAttribute('data-passage')) {
                    const linksInOcult = document.querySelectorAll('#Ocult a');
                    let foundLink = null;
                    const targetPassageValue = e.target.getAttribute('data-passage');
                    for (let i = 0; i < linksInOcult.length; i++) {
                        if (linksInOcult[i].textContent.trim() === targetPassageValue) {
                            foundLink = linksInOcult[i];
                            break;
                        }
                    }
                    if (foundLink) {
                        foundLink.click();
                    } else {
                        console.warn(`No se encontró el link de Harlowe oculto para el hotspot de pasaje: ${hotspotName}. Buscado: ${targetPassageValue}`);
                    }

                    // Secondary setter logic for passage type
                    const secondaryVariableName = e.target.getAttribute('data-variable-2');
                    const secondaryRawValue = e.target.getAttribute('data-valor-2');

                    if (secondaryVariableName && secondaryRawValue !== null && typeof window.Harlowe !== 'undefined' && typeof window.Harlowe.set === 'function' && typeof window.Harlowe.get === 'function') {
                        const secondaryTrimmedRawValue = secondaryRawValue.trim();
                        const arithmeticOperators = ['+', '-', '*', '/', '%'];
                        const startsWithArithmeticOperatorSecondary = arithmeticOperators.some(op => secondaryTrimmedRawValue.startsWith(op));

                        if (startsWithArithmeticOperatorSecondary) {
                            const operator = secondaryTrimmedRawValue.charAt(0);
                            const operandStr = secondaryTrimmedRawValue.substring(1).trim();
                            const operand = Number(operandStr);

                            if (!isNaN(operand)) {
                                let currentValue = Number(window.Harlowe.get(secondaryVariableName));
                                if (isNaN(currentValue)) {
                                    console.warn(`La variable secundaria '${secondaryVariableName}' no es un número. Se inicializa a 0 para realizar la operación aritmética.`);
                                    window.Harlowe.set(secondaryVariableName, 0);
                                    currentValue = 0;
                                }

                                let newValue;
                                switch (operator) {
                                    case '+': newValue = currentValue + operand; break;
                                    case '-': newValue = currentValue - operand; break;
                                    case '*': newValue = currentValue * operand; break;
                                    case '/':
                                        if (operand === 0) {
                                            console.warn(`División por cero en la variable secundaria '${secondaryVariableName}'.`);
                                            return;
                                        }
                                        newValue = currentValue / operand;
                                        break;
                                    case '%':
                                        if (operand === 0) {
                                            console.warn(`Módulo por cero en la variable secundaria '${secondaryVariableName}'.`);
                                            return;
                                        }
                                        newValue = currentValue % operand;
                                        break;
                                    default:
                                        console.warn(`Operador aritmético desconocido para la variable secundaria: ${operator}`);
                                        return;
                                }
                                window.Harlowe.set(secondaryVariableName, newValue);
                                console.log(`Variable de Twine secundaria '${secondaryVariableName}' actualizada aritméticamente a:`, newValue);
                            } else {
                                console.warn(`Operando inválido para la operación aritmética de la variable secundaria: ${operandStr}`);
                            }
                        } else {
                            let parsedValue;
                            if (!isNaN(secondaryTrimmedRawValue) && secondaryTrimmedRawValue !== '') {
                                parsedValue = Number(secondaryTrimmedRawValue);
                            } else {
                                if (secondaryTrimmedRawValue.startsWith('"') && secondaryTrimmedRawValue.endsWith('"') && secondaryTrimmedRawValue.length > 1) {
                                    parsedValue = secondaryTrimmedRawValue.substring(1, secondaryTrimmedRawValue.length - 1);
                                } else {
                                    parsedValue = secondaryTrimmedRawValue;
                                }
                            }
                            window.Harlowe.set(secondaryVariableName, parsedValue);
                            console.log(`Variable de Twine secundaria '${secondaryVariableName}' actualizada a:`, parsedValue);
                        }
                    } else if (secondaryVariableName && secondaryRawValue !== null) {
                        console.warn(`No se pudo actualizar la variable secundaria de Twine. Harlowe.set/get no disponible o secondaryVariableName inválido.`);
                    }

                } else if (e.target.hasAttribute('data_variable') && e.target.hasAttribute('data_valor')) {
                    // Primary setter logic (remains the same for setter type)
                    const variableName = e.target.getAttribute('data_variable');
                    const rawValue = e.target.getAttribute('data_valor');
                    
                    if (!variableName || typeof window.Harlowe === 'undefined' || typeof window.Harlowe.set !== 'function' || typeof window.Harlowe.get !== 'function') {
                        console.warn(`No se pudo actualizar la variable de Twine. Harlowe.set/get no disponible o variableName inválido.`);
                        return;
                    }

                    const trimmedRawValue = rawValue === null ? "" : rawValue.trim();
                    const arithmeticOperators = ['+', '-', '*', '/', '%'];
                    const startsWithArithmeticOperator = arithmeticOperators.some(op => trimmedRawValue.startsWith(op));

                    if (startsWithArithmeticOperator) {
                        const operator = trimmedRawValue.charAt(0);
                        const operandStr = trimmedRawValue.substring(1).trim();
                        const operand = Number(operandStr);

                        if (!isNaN(operand)) {
                            let currentValue = Number(window.Harlowe.get(variableName));
                            if (isNaN(currentValue)) {
                                console.warn(`La variable '${variableName}' no es un número. Se inicializa a 0 para realizar la operación aritmética.`);
                                window.Harlowe.set(variableName, 0);
                                currentValue = 0;
                            }

                            let newValue;
                            switch (operator) {
                                case '+': newValue = currentValue + operand; break;
                                case '-': newValue = currentValue - operand; break;
                                case '*': newValue = currentValue * operand; break;
                                case '/': 
                                    if (operand === 0) {
                                        console.warn(`División por cero en la variable '${variableName}'.`);
                                        return;
                                    }
                                    newValue = currentValue / operand; 
                                    break;
                                case '%': 
                                    if (operand === 0) {
                                        console.warn(`Módulo por cero en la variable '${variableName}'.`);
                                        return;
                                    }
                                    newValue = currentValue % operand; 
                                    break;
                                default:
                                    console.warn(`Operador aritmético desconocido: ${operator}`);
                                    return;
                            }
                            window.Harlowe.set(variableName, newValue);
                            console.log(`Variable de Twine '${variableName}' actualizada aritméticamente a:`, newValue);
                        } else {
                            console.warn(`Operando inválido para la operación aritmética: ${operandStr}`);
                        }
                    } else {
                        let parsedValue;
                        if (!isNaN(trimmedRawValue) && trimmedRawValue !== '') {
                            parsedValue = Number(trimmedRawValue);
                        } else {
                            if (trimmedRawValue.startsWith('"') && trimmedRawValue.endsWith('"') && trimmedRawValue.length > 1) {
                                parsedValue = trimmedRawValue.substring(1, trimmedRawValue.length - 1);
                            } else {
                                parsedValue = trimmedRawValue;
                            }
                        }
                        window.Harlowe.set(variableName, parsedValue);
                        console.log(`Variable de Twine '${variableName}' actualizada a:`, parsedValue);
                    }

                    // Secondary setter logic (remains the same for setter type)
                    const secondaryVariableName = e.target.getAttribute('data-variable-2');
                    const secondaryRawValue = e.target.getAttribute('data-valor-2');

                    if (secondaryVariableName && secondaryRawValue !== null) {
                        const secondaryTrimmedRawValue = secondaryRawValue.trim();
                        const arithmeticOperators = ['+', '-', '*', '/', '%'];
                        const startsWithArithmeticOperatorSecondary = arithmeticOperators.some(op => secondaryTrimmedRawValue.startsWith(op));

                        if (startsWithArithmeticOperatorSecondary) {
                            const operator = secondaryTrimmedRawValue.charAt(0);
                            const operandStr = secondaryTrimmedRawValue.substring(1).trim();
                            const operand = Number(operandStr);

                            if (!isNaN(operand)) {
                                let currentValue = Number(window.Harlowe.get(secondaryVariableName));
                                if (isNaN(currentValue)) {
                                    console.warn(`La variable secundaria '${secondaryVariableName}' no es un número. Se inicializa a 0 para realizar la operación aritmética.`);
                                    window.Harlowe.set(secondaryVariableName, 0);
                                    currentValue = 0;
                                }

                                let newValue;
                                switch (operator) {
                                    case '+': newValue = currentValue + operand; break;
                                    case '-': newValue = currentValue + operand; break;
                                    case '*': newValue = currentValue * operand; break;
                                    case '/':
                                        if (operand === 0) {
                                            console.warn(`División por cero en la variable secundaria '${secondaryVariableName}'.`);
                                            return;
                                        }
                                        newValue = currentValue / operand;
                                        break;
                                    case '%':
                                        if (operand === 0) {
                                            console.warn(`Módulo por cero en la variable secundaria '${secondaryVariableName}'.`);
                                            return;
                                        }
                                        newValue = currentValue % operand;
                                        break;
                                    default:
                                        console.warn(`Operador aritmético desconocido para la variable secundaria: ${operator}`);
                                        return;
                                }
                                window.Harlowe.set(secondaryVariableName, newValue);
                                console.log(`Variable de Twine secundaria '${secondaryVariableName}' actualizada aritméticamente a:`, newValue);
                            } else {
                                console.warn(`Operando inválido para la operación aritmética de la variable secundaria: ${operandStr}`);
                            }
                        } else {
                            let parsedValue;
                            if (!isNaN(secondaryTrimmedRawValue) && secondaryTrimmedRawValue !== '') {
                                parsedValue = Number(secondaryTrimmedRawValue);
                            } else {
                                if (secondaryTrimmedRawValue.startsWith('"') && secondaryTrimmedRawValue.endsWith('"') && secondaryTrimmedRawValue.length > 1) {
                                    parsedValue = secondaryTrimmedRawValue.substring(1, secondaryTrimmedRawValue.length - 1);
                                } else {
                                    parsedValue = secondaryTrimmedRawValue;
                                }
                            }
                            window.Harlowe.set(secondaryVariableName, parsedValue);
                            console.log(`Variable de Twine secundaria '${secondaryVariableName}' actualizada a:`, parsedValue);
                        }
                    }

                    // Update info display for the setter (existing logic)
                    if (twineInfoDisplay) {
                        if (infoText2ToDisplay) { // Show click info for setter
                            window.Harlowe.set('$tempInfoDisplay', infoText2ToDisplay);
                            twineInfoDisplay.style.display = 'block';
                        } else {
                            twineInfoDisplay.style.display = 'none';
                            window.Harlowe.set('$tempInfoDisplay', ''); // Clear display if no info
                        }
                    }
                }
            }
        });
        // --- FI DEL JAVASCRIPT ---
    </script>
</body>
</html>
